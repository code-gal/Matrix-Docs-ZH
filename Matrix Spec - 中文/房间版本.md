> [Matrix Specification](https://spec.matrix.org/v1.11/) | [Room Versions](https://spec.matrix.org/v1.11/rooms/)

# 房间版本

房间是 Matrix 运作的核心，并且对其中允许包含的内容有严格的规定。房间也可以具有处理不同任务的各种算法，例如当两个或更多事件在底层 DAG 中发生冲突时如何处理。为了通过新的算法或规则改进房间，使用“房间版本”来管理每个房间的一组期望。根据需要分配新的房间版本。

房间版本没有隐含的顺序或层级结构，它们的原则在放入规范后是不可改变的。虽然有一套推荐的版本，但一些房间可能会受益于其他版本引入的功能。房间通过“升级”到所需版本在不同版本之间迁移。由于版本不是顺序或层级结构，这意味着房间可以从版本 2“升级”到版本 1，如果需要如此。

### 功能矩阵[](https://spec.matrix.org/v1.11/rooms/#feature-matrix)

某些功能仅在特定房间版本中可用，例如敲门。下表显示了从客户端视角来看哪个版本支持哪些功能。服务器实现仍然可以参考下表，然而可能更感兴趣的是每个版本的详细规范。

| 功能 \ 版本    | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 |
|---------------|----|----|----|----|----|----|----|----|----|----|----|
| **敲门**      | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✔ | ✔ | ✔ | ✔ | ✔ |
| **受限加入规则**| ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✔ | ✔ | ✔ | ✔ |
| **`knock_restricted` 加入规则** | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✔ | ✔ |

### 房间版本完整列表[](https://spec.matrix.org/v1.11/rooms/#complete-list-of-room-versions)

房间版本分为两组：稳定和不稳定。稳定的房间版本可以安全使用。不稳定的房间版本是规范中未列出或因其他原因标记为不稳定的一切。由于各种原因，包括发现的安全漏洞和年龄，版本可以周期性地在稳定和不稳定之间切换。

如果房间运行的是稳定版本，客户端不应要求房间管理员升级其房间。创建新房间时，服务器应使用**房间版本 10**作为默认房间版本。

可用的房间版本有：

- [Version 1](https://spec.matrix.org/v1.11/rooms/v1) - **稳定**。最初的房间版本。
- [Version 2](https://spec.matrix.org/v1.11/rooms/v2) - **稳定**。实施状态解析版本 2。
- [Version 3](https://spec.matrix.org/v1.11/rooms/v3) - **稳定**。引入事件的 ID 是事件的哈希。
- [Version 4](https://spec.matrix.org/v1.11/rooms/v4) - **稳定**。在 v3 基础上使用 URL 安全的 base64 作为事件 ID。
- [Version 5](https://spec.matrix.org/v1.11/rooms/v5) - **稳定**。引入签名密钥有效期的强制执行。
- [Version 6](https://spec.matrix.org/v1.11/rooms/v6) - **稳定**。更改了事件的一些授权规则。
- [Version 7](https://spec.matrix.org/v1.11/rooms/v7) - **稳定**。引入敲门。
- [Version 8](https://spec.matrix.org/v1.11/rooms/v8) - **稳定**。增加一个加入规则允许其他房间的成员无需邀请加入。
- [Version 9](https://spec.matrix.org/v1.11/rooms/v9) - **稳定**。在 v8 基础上修复删除某些成员事件时的问题。
- [Version 10](https://spec.matrix.org/v1.11/rooms/v10) - **稳定**。强制执行仅整数的权限级别并添加 `knock_restricted` 加入规则。
- [Version 11](https://spec.matrix.org/v1.11/rooms/v11) - **稳定**。明确了删除算法。

### 房间版本语法[](https://spec.matrix.org/v1.11/rooms/#room-version-grammar)

房间版本用于更改可能与其他服务器不兼容的房间属性。例如，更改事件授权规则可能导致旧服务器由于不了解新规则而可能进入分裂状态。

房间版本被定义为一串字符，必须不超过 32 个码位长。房间版本必须不为空且只能包含字符 `a-z`，`0-9`，`.` 和 `-`。

房间版本不应被解析，应该将其视为不透明的标识符。仅由字符 `0-9` 和 `.`组成的房间版本保留给 Matrix 协议的未来版本。

合法房间版本的完整语法为：

```
room_version = 1*room_version_char
room_version_char = DIGIT
                  / %x61-7A         ; a-z
                  / "-" / "."
```

有效的房间版本示例：

- `1` （将由 Matrix 协议保留）
- `1.2` （将由 Matrix 协议保留）
- `1.2-beta`
- `com.example.version`

## 房间版本 1

此房间版本是房间的首个版本，包含其他房间版本的基石。

### 客户端考虑事项[](https://spec.matrix.org/v1.11/rooms/v1/#client-considerations)

在本地实现涂销算法的客户端应参考下面的[涂销](https://spec.matrix.org/v1.11/rooms/v1/#redactions)部分。

#### 涂销[](https://spec.matrix.org/v1.11/rooms/v1/#redactions)

一旦收到涂销事件，服务器必须去除任何不在以下列表中的键：

- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `prev_state`
- `auth_events`
- `origin`
- `origin_server_ts`
- `membership`

内容对象也必须去掉所有键，除非它是以下事件类型之一：

- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember) 允许键 `membership`。
- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate) 允许键 `creator`。
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules) 允许键 `join_rule`。
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 允许键 `ban`, `events`, `events_default`, `kick`, `redact`, `state_default`, `users`, `users_default`。
- [`m.room.aliases`](https://spec.matrix.org/v1.11/client-server-api#historical-events) 允许键 `aliases`。
- [`m.room.history_visibility`](https://spec.matrix.org/v1.11/client-server-api#mroomhistory_visibility) 允许键 `history_visibility`。

### 服务器实现组件[](https://spec.matrix.org/v1.11/rooms/v1/#server-implementation-components)

> [!warning] 警告：
> 本节包含的信息仅适用于服务器实现者。使用客户端-服务器 API 的应用程序通常不受此处复杂性影响。上述关于客户端考虑事项的章节是客户端-服务器 API 用例应参考的资源。

这里定义的算法只应适用于版本 1 房间。其他房间版本可能使用其他算法，因此服务器在执行给定算法之前应了解所处理房间的版本。

> [!warning] 警告：
> 尽管有很多房间使用房间版本 1，但已知会产生不良效果。实现支持房间版本 1 的服务器应注意一般应放宽限制，并且可能会出现不一致。

#### 涂销[](https://spec.matrix.org/v1.11/rooms/v1/#redactions-1)

[见上文](https://spec.matrix.org/v1.11/rooms/v1/#redactions)。

#### 事件 IDs[](https://spec.matrix.org/v1.11/rooms/v1/#event-ids)

一个事件有且仅有一个事件 ID。此房间版本中的事件 ID 格式为：

```
$opaque_id:domain
```

其中 `domain` 是创建房间的 homeserver 的 [服务器名称](https://spec.matrix.org/v1.11/appendices/#server-name)，而 `opaque_id` 是本地唯一的字符串。

域名仅用于命名空间，以避免不同 homeserver 之间标识符冲突的风险。并不意味着问题中的房间或事件仍然可以在相应的 homeserver 上使用。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v1/#event-format)

版本 1 房间中的事件具有以下结构：

##### `持久数据单元`

---

房间版本 1 和 2 的持久数据单元（事件）。

| 持久数据单元             |                                                                                                        |                                                                                                            |
| ------------------ | ------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------- |
| 名称                 | 类型                                                                                                     | 描述                                                                                                         |
| `auth_events`      | [[string\|[事件哈希](https://spec.matrix.org/v1.11/rooms/v1/#definition-persistent-data-unit_event-hash)]] | **必需：**<br><br>授权事件的事件 ID 和引用哈希，这些事件将允许此事件出现在房间中。<br><br>必须包含少于或等于 10 个事件。注意，如果使用了相关的授权事件选择规则，则永远不应该遇到此限制。 |
| `content`          | `object`                                                                                               | **必需：** 事件的内容。                                                                                             |
| `depth`            | `integer`                                                                                              | **必需：** `prev_events` 的最大深度加一。必须小于整数的最大值（2^63 - 1）。如果房间的深度已到达限制，则深度必须设置为限制。                                |
| `event_id`         | `string`                                                                                               | **必需：** PDU 的事件 ID。                                                                                        |
| `hashes`           | [事件哈希](https://spec.matrix.org/v1.11/rooms/v1/#definition-persistent-data-unit_event-hash)             | **必需：** PDU 的内容哈希值，遵循 [签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events) 中指定的算法。      |
| `origin_server_ts` | `integer`                                                                                              | **必需：** 创建此事件时起源 homeserver 的时间戳（以毫秒为单位）。                                                                  |
| `prev_events`      | [[string\|[事件哈希](https://spec.matrix.org/v1.11/rooms/v1/#definition-persistent-data-unit_event-hash)]] | **必需：**<br><br>创建此事件时 homeserver 知道的房间中最近事件的事件 ID 和引用哈希。<br><br>必须包含少于或等于 20 个事件。                          |
| `redacts`          | `string`                                                                                               | 对于涂销事件，被删除的事件 ID。                                                                                          |
| `room_id`          | `string`                                                                                               | **必需：** 房间标识符。                                                                                             |
| `sender`           | `string`                                                                                               | **必需：** 发送事件的用户 ID。                                                                                        |
| `signatures`       | `{string: {string: string}}`                                                                           | **必需：** PDU 的签名，遵循 [签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events) 中指定的算法。         |
| `state_key`        | `string`                                                                                               | 如果此键存在，则事件是状态事件，它将替换房间状态中具有相同 `type` 和 `state_key` 的先前事件。                                                  |
| `type`             | `string`                                                                                               | **必需：** 事件类型                                                                                               |
| `unsigned`         | [未签名数据](https://spec.matrix.org/v1.11/rooms/v1/#definition-persistent-data-unit_unsigneddata)          | 起源服务器添加的附加数据但不包括在 `signatures` 中。                                                                          |

| 事件哈希            |
|------------------|---|---|
| 名称              | 类型 | 描述 |
|------------------|---|---|
| `sha256`         | `string` | **必需：** 哈希。 |

| 未签名数据          |
|------------------|---|---|
| 名称              | 类型 | 描述 |
|------------------|---|---|
| `age`            | `integer` | 自此消息发送以来经过的毫秒数。 |

###### 示例

```json
{
  "auth_events": [
    "$af232176:example.org",
    {
      "sha256": "abase64encodedsha256hashshouldbe43byteslong"
    }
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "event_id": "$a4ecee13e2accdadf56c1025:example.com",
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$af232176:example.org",
    {
      "sha256": "abase64encodedsha256hashshouldbe43byteslong"
    }
  ],
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

##### 废弃事件内容架构[](https://spec.matrix.org/v1.11/rooms/v1/#deprecated-event-content-schemas)

发送到此版本房间的事件可以具有不同于其正常架构的格式。此类情况在此记录。

> [!warning] 警告：
> 这里描述的行为仅为了向后兼容而严格保留。homeserver 应采取合理措施防止用户发送这些所谓的“格式不正确”事件，而且绝不能将此处描述的行为作为默认依赖。

###### `m.room.power_levels` 事件接受字符串形式的值[](https://spec.matrix.org/v1.11/rooms/v1/#mroompower_levels-events-accept-values-as-strings)

为了保持与早期实现的向后兼容，[`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 事件中的每个整数值属性可以编码为字符串而不是整数。这包括 `events`、`notifications` 和 `users` 属性中的嵌套值。例如，以下是在此房间版本中有效的 `m.room.power_levels` 事件：

```json
{
  "content": {
    "ban": "50",
    "events": {
      "m.room.power_levels": "100"
    },
    "events_default": "0",
    "state_default": "50",
    "users": {
      "@example:localhost": "100"
    },
    "users_default": "0"
  },
  "origin_server_ts": 1432735824653,
  "room_id": "!jEsUZKDJdhlrceRyVU:example.org",
  "sender": "@example:example.org",
  "state_key": "",
  "type": "m.room.power_levels"
}
```

当值代表一个整数时，它们必须是以下格式：

- 一个单一的十进制整数，没有浮点值或小数点，可选地前置任意个零（`"100"`，`"000100"`）；
- 可以可选地在整数前加一个 `-` 或 `+` 字符（`"+100"`，`"-100"`）。
- 可选地包含任意数量的前导或尾随空白字符（`" 100 "`，`" 00100 "`，`" +100 "`，`" -100 "`）。

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v1/#authorization-rules)

影响授权的状态事件类型有：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 当明确提供时，可以从默认值推断出权限级别。例如，提到的 `sender` 权限级别也可以引用房间中用户的默认权限级别。

规则如下：

1. 如果类型为 `m.room.create`：
   1. 如果它有任何 `prev_events`，则拒绝。
   2. 如果 `room_id` 的域与 `sender` 的域不匹配，拒绝。
   3. 如果 `content.room_version` 存在且不是识别的版本，拒绝。
   4. 如果 `content` 没有 `creator` 属性，拒绝。
   5. 否则，允许。
2. 考虑事件的 `auth_events`：
   1. 如果给定 `type` 和 `state_key` 对有重复条目，拒绝。
   2. 如果有条目，其 `type` 和 `state_key` 不符合服务器规范中描述的[授权事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法，拒绝。
   3. 如果有条目本身在[收到 PDU 时执行的检查](https://spec.matrix.org/v1.11/server-server-api/#checks-performed-on-receipt-of-a-pdu)中被拒绝，拒绝。
   4. 如果条目中没有 `m.room.create` 事件，拒绝。
3. 如果房间状态中的 `m.room.create` 事件的 `content` 具有 `m.federate` 属性并设置为 `false`，且事件的 `sender` 域与创建事件的 `sender` 域不匹配，拒绝。
4. 如果类型为 `m.room.aliases`：
   1. 如果事件没有 `state_key`，拒绝。
   2. 如果发送者的域不匹配 `state_key`，拒绝。
   3. 否则，允许。
5. 如果类型为 `m.room.member`：
   1. 如果没有 `state_key` 属性，或 `content` 中没有 `membership` 属性，拒绝。
   2. 如果 `membership` 为 `join`：
      1. 如果唯一的前一事件是一个 `m.room.create` 事件且 `state_key` 为创建者，允许。
      2. 如果 `sender` 不匹配 `state_key`，拒绝。
      3. 如果 `sender` 被禁止，拒绝。
      4. 如果 `join_rule` 为 `invite`，则如果会员状态为 `invite` 或 `join`，允许。
      5. 如果 `join_rule` 为 `public`，允许。
      6. 否则，拒绝。
   3. 如果 `membership` 为 `invite`：
      1. 如果 `content` 有 `third_party_invite` 属性：
         1. 如果_目标用户_被禁止，拒绝。
         2. 如果 `content.third_party_invite` 没有 `signed` 属性，拒绝。
         3. 如果 `signed` 没有 `mxid` 和 `token` 属性，拒绝。
         4. 如果 `mxid` 不匹配 `state_key`，拒绝。
         5. 如果当前房间状态中没有匹配 `token` 的 `state_key` 的 `m.room.third_party_invite` 事件，拒绝。
         6. 如果 `sender` 不匹配 `m.room.third_party_invite` 的 `sender`，拒绝。
         7. 如果 `signed` 中的任何签名与 `m.room.third_party_invite` 事件中的任何公钥匹配（公钥在 `m.room.third_party_invite` 的 `content` 中，以单个在 `public_key` 属性中的公钥或在 `public_keys` 属性中的公钥列表形式存在），允许。
         8. 否则，拒绝。
      2. 如果发送者的当前会员状态不是 `join`，拒绝。
      3. 如果 _目标用户_ 的当前会员状态是 `join` 或 `ban`，拒绝。
      4. 如果发送者的权限级别大于等于 _invite level_，允许。
      5. 否则，拒绝。
   4. 如果 `membership` 为 `leave`：
      1. 如果 `sender` 匹配 `state_key`，且仅当该用户的当前会员状态为 `invite` 或 `join` 时，允许。
      2. 如果发送者的当前会员状态不是 `join`，拒绝。
      3. 如果 _目标用户_ 的当前会员状态是 `ban`，且发送者的权限级别小于 _ban level_，拒绝。
      4. 如果发送者的权限级别大于等于 _kick level_，且 _目标用户_ 的权限级别小于发送者的权限级别，允许。
      5. 否则，拒绝。
   5. 如果 `membership` 为 `ban`：
      1. 如果发送者的当前会员状态不是 `join`，拒绝。
      2. 如果发送者的权限级别大于等于 _ban level_，且 _目标用户_ 的权限级别小于发送者的权限级别，允许。
      3. 否则，拒绝。
   6. 否则，会员状态未知。拒绝。
6. 如果发送者的当前会员状态不是 `join`，拒绝。
7. 如果类型是 `m.room.third_party_invite`：
   1. 仅当发送者的当前权限级别大于等于 _invite level_ 时允许。
8. 如果事件类型的 _required power level_ 大于发送者的权限级别，拒绝。
9. 如果事件有一个以 `@` 开始的 `state_key`，且不匹配发送者，拒绝。
10. 如果类型是 `m.room.power_levels`：
    1. 如果 `content` 中的 `users` 属性不是一个以有效用户 ID 为键、以整数为值（或一个表示整数的字符串）的对象，拒绝。
    2. 如果房间中没有之前的 `m.room.power_levels` 事件，允许。
    3. 对属性 `users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`、`invite` 检查它们是否被添加、改变或移除。对于每个发现的改动：
       1. 如果当前值大于发送者的当前权限级别，拒绝。
       2. 如果新值大于发送者的当前权限级别，拒绝。
    4. 对 `events` 属性中每个被更改或移除的条目进行检查：
       1. 如果当前值大于发送者的当前权限级别，拒绝。
    5. 对 `events` 属性中每个被添加或更改的条目进行检查：
       1. 如果新值大于发送者的当前权限级别，拒绝。
    6. 对 `users` 属性中每个被更改或移除的条目（不包括发送者本身的条目）进行检查：
       1. 如果当前值大于或等于发送者的当前权限级别，拒绝。
    7. 对 `users` 属性中每个被添加或更改的条目进行检查：
       1. 如果新值大于发送者的当前权限级别，拒绝。
    8. 否则，允许。
11. 如果类型是 `m.room.redaction`：
    1. 如果发送者的权限级别大于等于 _redact level_，允许。
    2. 如果被涂销事件的 `event_id` 与 `m.room.redaction` 的 `event_id` 的域名相同，允许。
    3. 否则，拒绝。
12. 否则，允许。

> [!info] 信息：
> 这些规则的一些后果：
> 
> - 除非您是房间成员，否则唯一允许的操作（除非首次创建/加入）是：加入公共房间、接受或拒绝房间邀请。
> - 要取消对某人的封禁，您必须拥有大于或等于踢出 _和_ 封禁级别的权限级别 _并且_ 要大于目标用户的权限级别。

#### 状态解析[](https://spec.matrix.org/v1.11/rooms/v1/#state-resolution)

> [!warning] 警告：
> 已知房间版本 1 存在一个 bug，可能导致房间状态重置到房间状态的旧版本。例如，这可能意味着已加入房间的用户可能被删除，管理员和版主可能失去他们的权限级别，已被房间封禁的用户可能重新加入。其他状态事件，如房间名称或主题，也可能重置为先前版本。
> 
> 在房间版本 2 中引入的状态解析算法修复了这一问题。

事件 `E` 之后的房间状态 S′(E) 是相对于事件 E 之前的房间状态 S(E) 定义的，并且取决于 E 是状态事件还是消息事件：

- 如果 E 是消息事件，则 S′(E) = S(E)。
- 如果 E 是状态事件，那么 S′(E) 是 S(E)，只是它的条目对应于 `event_type` 和 `state_key` 被 E 的 `event_id` 替换。

事件 E 之前的房间状态 S(E) 是对事件 E 的 `prev_events` {E′, E″,…} 之后的状态集 {S′(E′), S′(E″),…} 的解析。

状态集的解析定义如下。解析的状态通过多个步骤累积；在这里我们用 R 表示到目前为止的解析结果。

- 首先用要解析的状态的并集设置 R，排除任何冲突的事件。
- 首先我们解决 `m.room.power_levels` 事件之间的冲突。如果没有冲突，跳过此步骤，否则：
  - 将待解析的状态中的所有 `m.room.power_levels` 事件组装成一个列表。
  - 按照 `depth` 递增然后 `sha1(event_id)` 递减的顺序对列表进行排序。
  - 将列表中的第一个事件添加到 R。
  - 对列表中的每个后续事件，检查事件是否会被房间 R 的授权规则允许。如果事件被允许，则使用事件更新 R 并继续列表中的下一个事件。如果不被允许，请停止并继续在 `m.room.join_rules` 事件下方。
- 针对 `m.room.join_rules` 事件的冲突重复上述过程。
- 针对 `m.room.member` 事件的冲突重复上述过程。
- 没有其他事件影响授权规则，因此对于其他所有冲突，只需选择通过 R 验证的最高深度和最低 `sha1(event_id)` 的事件，并将其添加到 R。

冲突发生在具有相同 (event_type，state_key) 的不同 `event_ids` 的状态之间。受其影响的事件称为冲突事件。

#### 普通 JSON[](https://spec.matrix.org/v1.11/rooms/v1/#canonical-json)

为了文中描述的原因，服务器不得严格强制执行附录中规定的 [JSON 格式](https://spec.matrix.org/v1.11/appendices#canonical-json)。

## 房间版本 2

此房间版本在[版本 1](https://spec.matrix.org/v1.11/rooms/v1) 的基础上引入了改进的状态解析算法。

### 客户端考虑事项[](https://spec.matrix.org/v1.11/rooms/v2/#client-considerations)

本房间版本中没有引入客户端考虑事项。在本地实现涂销除算法的客户端应参考下面的[涂销除](https://spec.matrix.org/v1.11/rooms/v2/#redactions)部分，以全面了解算法。

### 服务器实现组件[](https://spec.matrix.org/v1.11/rooms/v2/#server-implementation-components)

> [!warning] 警告：
> 本节包含的信息仅限于服务器实现者。使用客户端-服务器 API 的应用程序通常不受此处详述的影响，可以安全地忽略它们的存在。

房间版本 2 使用[房间版本 1](https://spec.matrix.org/v1.11/rooms/v1) 的基本组件，仅更改状态解析算法。

#### 状态解析[](https://spec.matrix.org/v1.11/rooms/v2/#state-resolution)

**[本版本新增]**

事件 E 之后的房间状态 S′(E) 是相对于事件 E 之前的房间状态 S(E) 定义的，并且取决于 E 是状态事件还是消息事件：

- 如果 E 是消息事件，则 S′(E) = S(E)。
- 如果 E 是状态事件，那么 S′(E) 是 S(E)，只是它的条目对应于 `event_type` 和 `state_key` 是被 E 的 `event_id` 替换。

事件 E 之前的房间状态 S(E) 是对事件 E 的 `prev_event`s {E_1, E_2, …} 之后的状态集 {S′(E_1), S′(E_2),…} 的解析。状态集的解析由下面的算法给出。

##### 定义[](https://spec.matrix.org/v1.11/rooms/v2/#definitions)

版本 2 房间的状态解析算法使用以下定义，给定的房间状态集 {S_1, S_2, …}：

**权限事件。** 权限事件是具有类型 `m.room.power_levels` 或 `m.room.join_rules` 的状态事件，或者发送者与 `state_key` 不匹配的且 `membership` 是 `leave` 或 `ban` 的类型 `m.room.member` 的状态事件。权限事件是可能移除某人做某事能力的事件。

**无冲突状态映射和冲突状态集。** 状态映射 S_i 的键为 `(event_type, state_key)` 形式的字符串 2 元组。值 V 为状态事件。键值对(K, V)遍布所有状态映射S_i分成两个集合。如果给定键K在每个S_i中都具有相同的值V，则对(K, V)属于无冲突状态映射。否则，V属于冲突状态集。

请注意，无冲突状态映射对每个键K只有一个事件，而冲突状态集可能包含多个具有相同键的事件。

**认证链。** 事件E的认证链是包含E的所有认证事件、它们的所有认证事件等的集合，递归地追溯到房间的开始。换句话说，这些是事件的`auth_events`链接所引导的图中可访问的事件。

**认证差异。** 首先计算每个状态S_i的完整认证链，即每个事件在S_i中的认证链，并在_认证链_ C_i 中计算出不出现在每个认证链中的每个事件。认证差异是 ∪_C_i_ − ∩_C_i_。

**完整冲突集。** 完整冲突集是冲突状态集与认证差异的并集。

**反向拓扑权限排序。** 事件集的反向拓扑权限排序是根据授权事件形成的 DAG 的字典序最小拓扑排序。反向拓扑权限排序按时间顺序从最早的事件到最晚的事件排序。用于比较两个拓扑排序以确定哪个是字典序最小的事件比较关系如下：对于事件x和y，当

1. x的发送者在他们各自的`auth_event`中比y的发送者有_较高的_权限级别；或
2. 发送者具有相同的权限级别，但x的`origin_server_ts`小于y的`origin_server_ts`；或
3. 发送者具有相同的权限级别，并且事件具有相同的`origin_server_ts`，但x的`event_id`小于y的`event_id`。

使用 Kahn 算法进行拓扑排序，在每个步骤选择所有候选顶点中的最小顶点，并使用上述比较关系确定反向拓扑权限排序。

**主线排序。** 令P = P_0 是一个`m.room.power_levels`事件。从 i = 0 开始，重复获取P_i+1，这是P_i的`auth_events`中的`m.room.power_levels`事件。递增 i 并重复，直到P_i的`auth_events`中没有`m.room.power_levels`事件为止。P_0的主线是以这种方式获取的 [_P_0, ... , _Pn_] 事件列表。

令e = e_0 是另一个事件（可能是另一个`m.room.power_levels`事件）。我们可以计算一个类似的 [_e_1, ..., _em_] 事件列表，其中 e_j+1 是 e_j 的`auth_events`中`m.room.power_levels`事件，em没有`m.room.power_levels`事件在其`auth_events`中（注意我们开始的事件 e_0 不包含在此列表中。还注意到这可能为空，因为 e 可能在其`auth_events`中根本没有引用`m.room.power_levels`事件）。

现在将这两个列表进行如下比较。

- 寻找最小的索引 _j_ ≥ 1，其中 _ej_ 属于 _P_ 的主线。
- 如果这样的 _j_ 存在，则 _ej_ = _P_i_，对于某个唯一的索引 _i_ ≥ 0。否则，设 _i_ = ∞，其中 ∞ 是大于任何整数的哨兵值。
- 在两种情况下，_e_ 的 _主线位置_ 是 _i_。

根据从 _P_ 计算的主线位置，事件集合的 _基于主线的排序_ 是使用下述事件比较关系从小到大排序的：对于事件 _x_ 和 _y_，如果

1. _x_ 的主线位置大于 _y_ 的主线位置（即 _x_ 的授权链基于主线中的一个更早的事件）; 或者
2. 事件的主线位置相同，但 _x_ 的 `origin_server_ts` 少于 _y_ 的 `origin_server_ts`; 或者
3. 事件的主线位置相同且它们的 `origin_server_ts` 相同，但 _x_ 的 `event_id` 少于 _y_ 的 `event_id`。

**迭代授权检查。** _迭代授权检查算法_ 以初始房间状态和排序的状态事件列表作为输入，通过遍历事件列表并应用状态事件到房间状态来构建新的房间状态，如果状态事件符合 [授权规则](https://spec.matrix.org/v1.11/server-server-api#authorization-rules)。如果状态事件不符合授权规则，则忽略该事件。如果检查授权规则所需的 `(event_type, state_key)` 键不在状态中，则如果授权事件未被拒绝，则使用事件的 `auth_events` 中的适当状态事件。

##### 算法[](https://spec.matrix.org/v1.11/rooms/v2/#algorithm)

状态集合的 _解决_ 如下：

1. 选择出现在 _全部冲突集合_ 中的所有权力事件的集合 _X_。对于每个这样的权力事件 _P_，通过添加 _P_ 的授权链中也属于全部冲突集合的事件来扩充 _X_。使用 _反拓扑权力排序_ 将 $X$ 排序成列表。
2. 从 _无冲突状态映射_ 开始，应用 _迭代授权检查算法_，对前一步中的事件列表，得到一个部分解决的状态。
3. 对所有在步骤 1 中未选取的剩余事件，按根据步骤 2 中获得的部分解决状态中的权力级别的主线排序进行排序。
4. 将 _迭代授权检查算法_ 应用于部分解决状态和前一步中的事件列表。
5. 通过替换任何事件为同键的 _无冲突状态映射_ 中的事件（如果存在）来更新结果，以获得最终解决的状态。

##### 被拒绝的事件[](https://spec.matrix.org/v1.11/rooms/v2/#rejected-events)

由于未通过事件状态的授权检查而被拒绝的事件，将按照算法正常处理，除非另有说明。

注意，由于未通过其授权链的授权而被拒绝的事件不应出现在流程中，因为它们不应出现在状态中（算法仅使用出现在状态集合或状态集合中的事件的授权链中的事件）。

> [!info] 理由：
> 这有助于确保不同服务器对状态的视图更有可能收敛，因为事件的拒绝状态可能不同。如果在一个服务器通过一个故障或恶意行为难以检测出损坏的状态加入房间时会发生这种情况。状态的收敛是一个理想特性，因为它确保了房间内的所有用户对房间状态拥有（大部分）一致的视图。如果对不同服务器的状态视图存在差异，可能导致房间的分裂，比如说服务器对某些人成员身份产生分歧。
> 
> 直观上，使用被拒绝的事件可能看来是危险的，然而：
> 
> 1. 服务器不能随意创建状态，因为它们仍然需要通过基于事件授权链的授权检查（例如，它们不能在之前没有的情况下给自己赋予权力级别）。
> 2. 为了使先前被拒绝的事件通过授权，必须有一组允许该事件的状态。因此，恶意服务器可以制造一个分支，声称状态是那组特定状态，复制被拒绝事件指向该分支，并发送事件。复制的事件随后将通过授权检查。因此，忽视被拒绝的事件不会消除任何潜在的攻击向量。

被拒绝的授权事件故意排除在迭代授权检查之外，因为授权事件在迭代授权检查期间不会重新授权（尽管非授权事件会）。

### 从 v1 未更改[](https://spec.matrix.org/v1.11/rooms/v2/#unchanged-from-v1)

以下部分自 v1 以来没有修改，但为完整性提供。

#### 涂销[](https://spec.matrix.org/v1.11/rooms/v2/#redactions)

收到涂销事件时，服务器必须删除不在下述列表中的所有键：

- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `prev_state`
- `auth_events`
- `origin`
- `origin_server_ts`
- `membership`

内容对象也必须删除所有键，除非是以下事件类型之一：

- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember) 允许键 `membership`。
- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate) 允许键 `creator`。
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules) 允许键 `join_rule`。
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 允许键 `ban`，`events`，`events_default`，`kick`，`redact`，`state_default`，`users`，`users_default`。
- [`m.room.aliases`](https://spec.matrix.org/v1.11/client-server-api#historical-events) 允许键 `aliases`。
- [`m.room.history_visibility`](https://spec.matrix.org/v1.11/client-server-api#mroomhistory_visibility) 允许键 `history_visibility`。

#### 事件 ID[](https://spec.matrix.org/v1.11/rooms/v2/#event-ids)

一个事件恰好有一个事件 ID。在此房间版本中，事件 ID 格式为：

```
$opaque_id:domain
```

其中 `domain` 是创建房间的 homeserver 的 [服务器名称](https://spec.matrix.org/v1.11/appendices/#server-name)，`opaque_id` 是本地唯一的字符串。

域仅用于命名空间，以避免不同 homeserver 之间标识符的冲突风险。并不暗示该房间或事件在对应 homeserver 上仍然可用。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v2/#event-format)

此版本的房间中的事件具有以下结构：

##### `持久数据单元`

---

房间版本 1 和 2 的持久数据单元（事件）。

|持久数据单元|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`auth_events`|[[string\|[事件哈希](https://spec.matrix.org/v1.11/rooms/v2/#definition-persistent-data-unit_event-hash)]]|**必需:**<br><br>允许此事件存在于房间的授权事件的事件 ID 和参考哈希。<br><br>最多包含 10 个事件。注意，如果使用相关的授权事件选择规则，此限制应该不会遇到。|
|`content`|`object`|**必需:** 事件的内容。|
|`depth`|`integer`|**必需:** `prev_events` 的最大深度加一。必须小于整数的最大值 (2^63 - 1)。如果房间的深度已达到限制，则深度必须设置为限制。|
|`event_id`|`string`|**必需:** PDU 的事件 ID。|
|`hashes`|[事件哈希](https://spec.matrix.org/v1.11/rooms/v2/#definition-persistent-data-unit_event-hash)|**必需:** PDU 的内容哈希，遵循在[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`origin_server_ts`|`integer`|**必需:** 创建该事件时源 homeserver 上的时间戳，以毫秒为单位。|
|`prev_events`|[[string\|[事件哈希](https://spec.matrix.org/v1.11/rooms/v2/#definition-persistent-data-unit_event-hash)]]|**必需:**<br><br>homeserver 在创建此事件时已知的房间中的最新事件的事件 ID 和参考哈希。<br><br>最多包含 20 个事件。|
|`redacts`|`string`|对于涂销事件，被涂销事件的 ID。|
|`room_id`|`string`|**必需:** 房间标识符。|
|`sender`|`string`|**必需:** 发送此事件的用户的 ID。|
|`signatures`|`{string: {string: string}}`|**必需:** PDU 的签名，遵循在[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`state_key`|`string`|如果存在此键，则事件为状态事件，并将替换房间状态中具有相同 `type` 和 `state_key` 的先前事件。|
|`type`|`string`|**必需:** 事件类型|
|`unsigned`|[未签名数据](https://spec.matrix.org/v1.11/rooms/v2/#definition-persistent-data-unit_unsigneddata)|由源服务器添加的附加数据，但未涵盖在 `signatures` 中。|

|事件哈希|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`sha256`|`string`|**必需:** 哈希。|

|未签名数据|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`age`|`integer`|自此消息发送以来经过的毫秒数。|

###### 示例

```json
{
  "auth_events": [
    "$af232176:example.org",
    {
      "sha256": "abase64encodedsha256hashshouldbe43byteslong"
    }
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "event_id": "$a4ecee13e2accdadf56c1025:example.com",
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$af232176:example.org",
    {
      "sha256": "abase64encodedsha256hashshouldbe43byteslong"
    }
  ],
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

##### 已弃用的事件内容模式[](https://spec.matrix.org/v1.11/rooms/v2/#deprecated-event-content-schemas)

发送到此版本的房间的事件可以具有与其正常模式不同的格式。此类情况在此进行了记录。

> [!warning] 警告：
> 此处描述的行为严格保留仅用于向后兼容。homeserver 应采取合理的预防措施，以防止用户发送这些所谓的“格式错误”的事件，并且绝不可依赖此处描述的行为作为默认行为。

###### `m.room.power_levels` 事件接受字符串形式的值[](https://spec.matrix.org/v1.11/rooms/v2/#mroompower_levels-events-accept-values-as-strings)

为了保持与早期实现的向后兼容性，[`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 事件中的每个整数值属性可以编码为字符串而不是整数。这包括 `events`、`notifications` 和 `users` 属性中的嵌套值。例如，以下是在此房间版本中有效的 `m.room.power_levels` 事件：

```json
{
  "content": {
    "ban": "50",
    "events": {
      "m.room.power_levels": "100"
    },
    "events_default": "0",
    "state_default": "50",
    "users": {
      "@example:localhost": "100"
    },
    "users_default": "0"
  },
  "origin_server_ts": 1432735824653,
  "room_id": "!jEsUZKDJdhlrceRyVU:example.org",
  "sender": "@example:example.org",
  "state_key": "",
  "type": "m.room.power_levels"
}
```

当值代表一个整数时，它们必须采用以下格式：

- 单个十进制整数，不能有浮点值或小数点，可能带有任意数量的前导零（如 `"100"`、`"000100"`）；
- 可选地在整数前加一个 `-` 或 `+` 符号（如 `"+100"`、`"-100"`）。
- 可选地在前后带有任意数量的空格字符（如 `" 100 "`、`" 00100 "`、`" +100 "`、`" -100 "`）。

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v2/#authorization-rules)

影响授权的状态事件类型有：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 当未显式提供时，权力级别是根据默认值推断的。例如，提到 `sender` 的权力级别也可以指指在房间中的用户的默认权力级别。

规则如下：

1. 如果类型是 `m.room.create`：
    1. 如果有任何 `prev_events`，则拒绝。
    2. 如果 `room_id` 的域与 `sender` 的域不匹配，则拒绝。
    3. 如果 `content.room_version` 存在且不是已识别的版本，则拒绝。
    4. 如果 `content` 没有 `creator` 属性，则拒绝。
    5. 否则，允许。
2. 考虑事件的 `auth_events`：
    1. 如果对于给定的 `type` 和 `state_key` 对存在重复条目，则拒绝。
    2. 如果存在条目，其 `type` 和 `state_key` 不匹配服务器规范中描述的[授权事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法所指定的那些，则拒绝。
    3. 如果存在在[接收 PDU 时执行的检查](https://spec.matrix.org/v1.11/server-server-api/#checks-performed-on-receipt-of-a-pdu)中被拒绝的条目，则拒绝。
    4. 如果条目中没有 `m.room.create` 事件，则拒绝。
3. 如果 `m.room.create` 事件在房间状态中的 `content` 属性将 `m.federate` 设置为 `false`，并且事件的 `sender` 域与创建事件的 `sender` 域不匹配，则拒绝。
4. 如果类型是 `m.room.aliases`：
    1. 如果事件没有 `state_key`，则拒绝。
    2. 如果发送方的域名不匹配 `state_key`，则拒绝。
    3. 否则，允许。
5. 如果类型是 `m.room.member`：
    1. 如果没有 `state_key` 属性，或 `content` 中没有 `membership` 属性，则拒绝。
    2. 如果 `membership` 是 `join`：
        1. 如果仅有的先前事件是 `m.room.create`，并且 `state_key` 是创建者，则允许。
        2. 如果 `sender` 不匹配 `state_key`，则拒绝。
        3. 如果 `sender` 被 banned，则拒绝。
        4. 如果 `join_rule` 是 `invite`，则在会员状态是 `invite` 或 `join` 时允许。
        5. 如果 `join_rule` 是 `public`，则允许。
        6. 否则，拒绝。
    3. 如果 `membership` 是 `invite`：
        1. 如果 `content` 有 `third_party_invite` 属性：
            1. 如果 _目标用户_ 被 banned，则拒绝。
            2. 如果 `content.third_party_invite` 没有 `signed` 属性，则拒绝。
            3. 如果 `signed` 没有 `mxid` 和 `token` 属性，则拒绝。
            4. 如果 `mxid` 不匹配 `state_key`，则拒绝。
            5. 如果当前房间状态中没有匹配 `token` 的 `state_key` 的 `m.room.third_party_invite` 事件，则拒绝。
            6. 如果 `sender` 没有与 `m.room.third_party_invite` 的 `sender` 匹配，则拒绝。
            7. 如果 `signed` 中的任何签名与 `m.room.third_party_invite` 事件中的任何公钥匹配，则允许。公钥位于 `m.room.third_party_invite` 的 `content` 中：
                1. 在 `public_key` 属性中的单个公钥。
                2. 在 `public_keys` 属性中的一组公钥。
            8. 否则，拒绝。
        2. 如果 `sender` 的当前成员状态不是 `join`，则拒绝。
        3. 如果 _目标用户_ 的当前成员状态是 `join` 或 `ban`，则拒绝。
        4. 如果 `sender` 的权力级别大于或等于 _邀请级别_，则允许。
        5. 否则，拒绝。
    4. 如果 `membership` 是 `leave`：
        1. 如果 `sender` 匹配 `state_key`，则仅在该用户的当前成员状态是 `invite` 或 `join` 时允许。
        2. 如果 `sender` 的当前成员状态不是 `join`，则拒绝。
        3. 如果 _目标用户_ 的当前成员状态是 `ban`，并且 `sender` 的权力级别小于 _ban 级别_，则拒绝。
        4. 如果 `sender` 的权力级别大于或等于 _kick 级别_，并且 _目标用户_ 的权力级别小于 `sender` 的权力级别，则允许。
        5. 否则，拒绝。
    5. 如果 `membership` 是 `ban`：
        1. 如果 `sender` 的当前成员状态不是 `join`，则拒绝。
        2. 如果 `sender` 的权力级别大于或等于 _ban 级别_，并且 _目标用户_ 的权力级别小于 `sender` 的权力级别，则允许。
        3. 否则，拒绝。
    6. 否则，成员状态未知。拒绝。
6. 如果 `sender` 的当前成员状态不是 `join`，则拒绝。
7. 如果类型是 `m.room.third_party_invite`：
    1. 仅当 `sender` 的当前权力级别大于或等于 _邀请级别_ 时允许。
8. 如果事件类型的 _需要的权力级别_ 大于 `sender` 的权力级别，则拒绝。
9. 如果事件有以 `@` 开头的 `state_key` 且不匹配 `sender`，则拒绝。
10. 如果类型是 `m.room.power_levels`：
    1. 如果 `content` 中的 `users` 属性不是一种含有有效用户 ID 的键且值为整数（或表示整数的字符串）的对象，则拒绝。
    2. 如果房间中没有先前的 `m.room.power_levels` 事件，则允许。
    3. 对于属性 `users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`、`invite` 检查它们是否被添加、改变或删除。对于每个找到的变更：
        1. 如果当前值大于 `sender` 的当前权力级别，则拒绝。
        2. 如果新值大于 `sender` 的当前权力级别，则拒绝。
    4. 对于 `events` 属性中被更改或删除的每个条目：
        1. 如果当前值大于 `sender` 的当前权力级别，则拒绝。
    5. 对于 `events` 属性中被添加或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权力级别，则拒绝。
    6. 对于 `users` 属性中被更改或删除的每个条目，除了 `sender` 的条目之外：
        1. 如果当前值大于或等于 `sender` 的当前权力级别，则拒绝。
    7. 对于 `users` 属性中被添加或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权力级别，则拒绝。
    8. 否则，允许。
11. 如果类型是 `m.room.redaction`：
    1. 如果 `sender` 的权力级别大于或等于 _redact 级别_，则允许。
    2. 如果被涂销事件的 `event_id` 的域与 `m.room.redaction` 的 `event_id` 的域相同，则允许。
    3. 否则，拒绝。
12. 否则，允许。

> [!info] 信息：
> 这些规则的一些后果：
> 
> - 除了初始创建/加入，除非您是房间成员，否则唯一允许的操作是：加入公共房间；接受或拒绝房间邀请。
> - 若要解除对某人的禁令，您必须具有高于或等于踢出 _和_ 禁止级别，_和_ 高于目标用户的权力级别。

#### 规格化 JSON[](https://spec.matrix.org/v1.11/rooms/v2/#canonical-json)

由于描述的原因，服务器必须不得严格实施 [附录](https://spec.matrix.org/v1.11/appendices#canonical-json) 中规定的 JSON 格式。

## 房间版本 3

此房间版本基于[版本 2](https://spec.matrix.org/v1.11/rooms/v2)，具有改进的事件格式。

### 客户端考虑事项[](https://spec.matrix.org/v1.11/rooms/v3/#client-considerations)

此房间版本更改了发送给客户端的事件 ID 格式。 客户端应该意识到这些事件 ID 可能包含斜杠和其他潜在的有问题的字符。 客户端应该将事件 ID 视为不透明标识符，并且不应该尝试将其解析为可用的形式，就像其他房间版本一样。

客户端应该期望看到事件 ID 从 `$randomstring:example.org` 格式更改为类似 `$acR1l0raoZnm60CBwAVgqbZqoO/mYU81xysh1u7XcJk`（注意缺少域名和潜在问题的斜杠）。

即使在此房间版本中未更改，实现在客户端本地的涂销算法的客户端也应该参考下面的 [涂销](https://spec.matrix.org/v1.11/rooms/v3/#redactions) 部分以获得完整的概述。

### 服务器实现组件[](https://spec.matrix.org/v1.11/rooms/v3/#server-implementation-components)

> [!warning] 警告：
> 本节包含的信息仅适用于服务器实现者。 使用客户端-服务器 API 的应用程序通常不受此处包含的复杂性影响。 上述有关客户关注事项的部分是客户端-服务器 API 的使用案例应该参考的资源。

房间版本 3 使用此处描述的事件格式以及[房间版本 2](https://spec.matrix.org/v1.11/rooms/v2)描述的所有剩余行为。

#### 处理涂销[](https://spec.matrix.org/v1.11/rooms/v3/#handling-redactions)

在房间版本 1 和 2 中，涂销明确是[授权规则](https://spec.matrix.org/v1.11/rooms/v1/#authorization-rules)的第 11 条规则的一部分。从房间版本 3 开始，这些条件不再存在，如[此版本的授权规则](https://spec.matrix.org/v1.11/rooms/v3/#authorization-rules)所示。

虽然授权规则始终接受对事件的涂销，但不应将它们发送给客户端，直到涂销事件和涂销影响的事件都已接收并且可以验证。如果两个事件都有效并且服务器已看到，则当满足以下条件之一时，服务器会应用涂销：

1. 涂销事件的 `sender` 权力级别大于或等于 _redact 级别_。
2. 涂销事件的 `sender` 域与原始事件的 `sender` 域匹配。

如果服务器会应用涂销，则涂销事件也会发送给客户端。否则，服务器只是等待一个有效的匹配事件的到来，然后可以重新检查上述条件。

#### 事件 ID[](https://spec.matrix.org/v1.11/rooms/v3/#event-ids)

> [!info] 理由：
> 在其他房间版本（即版本 1 和 2 中），事件 ID 是与事件其他部分不同的独特字段，必须将其作为这样进行追踪。这导致了服务器在接收具有相同 ID 的事件时，在同一个或不同的房间中，难以跟踪应使用的事件。通过移除专用事件 ID 的使用，服务器需要追踪事件的哈希来确定其 ID。

**[此版本新增]** 事件 ID 是事件的 [引用哈希](https://spec.matrix.org/v1.11/server-server-api#calculating-the-reference-hash-for-an-event)，使用 [无填充 Base64](https://spec.matrix.org/v1.11/appendices#unpadded-base64) 编码，前缀为 `$`。通过这种方法生成的事件 ID 应类似于 `$CD66HAED5npg6074c6pDtLKalHjVfYb2q4Q3LZgrW6o`。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v3/#event-format)

当事件通过联邦发送时，不再包含 `event_id` 字段。接收事件的服务器应自行计算相关的事件 ID。

此外，`auth_events` 和 `prev_events` 字段的格式已更改：而不是 `(event_id, hash)` 对的列表，现在改为简单的事件 ID 列表。

对事件格式的这些更改意味着服务器必须知道包含传入事件的房间的版本，以便能够正确解析和处理事件。这通过对服务器-服务器 API（例如在[`GET /_matrix/federation/v1/make_join/{roomId}/{userId}`](https://spec.matrix.org/v1.11/server-server-api/#get_matrixfederationv1make_joinroomiduserid) 的响应中包含 `room_version`）的更改来实现。

v3 房间中的事件完整结构如下所示。

##### `持久数据单元`

---

房间版本 3 及其后的持久数据单元（事件）。

|持久数据单元|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`auth_events`|`[string]`|**必需:**<br><br>允许此事件存在于房间的授权事件的事件 ID。<br><br>最多包含 10 个事件。注意，如果使用相关的授权事件选择规则，此限制应该不会遇到。|
|`content`|`object`|**必需:** 事件的内容。|
|`depth`|`integer`|**必需:** `prev_events` 的最大深度加一。必须小于整数的最大值 (2^63 - 1)。如果房间的深度已达到限制，则深度必须设置为限制。|
|`hashes`|[事件哈希](https://spec.matrix.org/v1.11/rooms/v3/#definition-persistent-data-unit_event-hash)|**必需:** PDU 的内容哈希，遵循在[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`origin_server_ts`|`integer`|**必需:** 创建该事件时源 homeserver 上的时间戳，以毫秒为单位。|
|`prev_events`|`[string]`|**必需:**<br><br>homeserver 在创建此事件时已知的房间中的最新事件的事件 ID。<br><br>最多包含 20 个事件。|
|`redacts`|`string`|对于涂销事件，被涂销事件的 ID。|
|`room_id`|`string`|**必需:** 房间标识符。|
|`sender`|`string`|**必需:** 发送此事件的用户的 ID。|
|`signatures`|`{string: {string: string}}`|**必需:** PDU 的签名，遵循在[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`state_key`|`string`|如果存在此键，则事件为状态事件，并将替换房间状态中具有相同 `type` 和 `state_key` 的先前事件。|
|`type`|`string`|**必需:** 事件类型|
|`unsigned`|[未签名数据](https://spec.matrix.org/v1.11/rooms/v3/#definition-persistent-data-unit_unsigneddata)|由源服务器添加的附加数据，但未涵盖在 `signatures` 中。|

|事件哈希|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`sha256`|`string`|**必需:** 哈希。|

|未签名数据|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`age`|`integer`|自此消息发送以来经过的毫秒数。|

###### 示例

```json
{
  "auth_events": [
    "$base64encodedeventid",
    "$adifferenteventid"
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$base64encodedeventid",
    "$adifferenteventid"
  ],
  "redacts": "$some/old+event",
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

##### 已弃用的事件内容模式[](https://spec.matrix.org/v1.11/rooms/v3/#deprecated-event-content-schemas)

发送到此版本的房间的事件可以具有与其正常模式不同的格式。此类情况在此进行了记录。

> [!warning] 警告：
> 此处描述的行为严格保留仅用于向后兼容。homeserver 应采取合理的预防措施，以防止用户发送这些所谓的“格式错误”的事件，并且绝不可依赖此处描述的行为作为默认操作。

###### `m.room.power_levels` 事件接受字符串形式的值[](https://spec.matrix.org/v1.11/rooms/v3/#mroompower_levels-events-accept-values-as-strings)

为了保持与早期实现的向后兼容性，[`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 事件中的每个整数值属性可以编码为字符串而不是整数。这包括 `events`、`notifications` 和 `users` 属性中的嵌套值。例如，以下是在此房间版本中有效的 `m.room.power_levels` 事件：

```json
{
  "content": {
    "ban": "50",
    "events": {
      "m.room.power_levels": "100"
    },
    "events_default": "0",
    "state_default": "50",
    "users": {
      "@example:localhost": "100"
    },
    "users_default": "0"
  },
  "origin_server_ts": 1432735824653,
  "room_id": "!jEsUZKDJdhlrceRyVU:example.org",
  "sender": "@example:example.org",
  "state_key": "",
  "type": "m.room.power_levels"
}
```

当该值代表一个整数时，必须采用以下格式：

- 一个基于十进制的单一整数，不允许浮点值或者小数点，可以有任意数量的前导零（`"100"`，`"000100"`）；
- 可以选择一个单一的 `-` 或 `+` 字符作为整数前缀（`"+100"`，`"-100"`）。
- 可以选择带有任意数量的前导或尾随空白字符（`" 100 "`，`" 00100 "`，`" +100 "`，`" -100 "`）。

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v3/#authorization-rules)

> [!info] 信息：
> **[此版本新增]** `m.room.redaction` 事件与其他事件一样受授权规则的约束。实际上，这意味着除非 `m.room.power_levels` 事件通过其 `events` 或 `events_default` 属性对 `m.room.redaction` 事件设置了权限等级要求，否则通常受授权规则允许。特别是，_修订等级_ 并不在授权规则的考虑之列。
>
> 发送修订事件的能力并不意味着修订本身应该被执行。接收服务器必须执行额外的检查，如 [处理修订](https://spec.matrix.org/v1.11/rooms/v3/#handling-redactions) 部分所述。

**[此版本新增]** 在房间版本1和2中，事件需要来自 `event_id` 域的签名才能视为有效。该房间版本不在联邦中包含 `event_id`，因此不需要该服务器的签名。然而，事件必须仍然由 `sender` 属性指示的服务器签名。

影响授权的状态事件类型有：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 在没有明确提供时，权限等级推断默认值。例如，提到 `sender` 的权限等级时也可以指房间中用户的默认权限等级。

完整的规则列表，截至房间版本3，如下：

1. 如果类型是 `m.room.create`：
    1. 如果有任何 `prev_events`，拒绝。
    2. 如果 `room_id` 的域与 `sender` 的域不匹配，拒绝。
    3. 如果 `content.room_version` 存在且不是识别版本，拒绝。
    4. 如果 `content` 没有 `creator` 属性，拒绝。
    5. 否则，允许。
2. 考虑事件的 `auth_events`：
    1. 如果对于给定的 `type` 和 `state_key` 对有重复条目，拒绝。
    2. 如果存在条目，其 `type` 和 `state_key` 与服务器规范中描述的 [auth events selection](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection) 算法指定的不匹配，拒绝。
    3. 如果存在条目，其本身在 [接收到PDU时执行的检查](https://spec.matrix.org/v1.11/server-server-api/#checks-performed-on-receipt-of-a-pdu) 下被拒绝，拒绝。
    4. 如果条目中没有 `m.room.create` 事件，拒绝。
3. 如果房间状态中 `m.room.create` 事件的 `content` 有属性 `m.federate` 被设置为 `false`，且事件的 `sender` 域与创建事件的 `sender` 域不匹配，拒绝。
4. 如果类型是 `m.room.aliases`：
    1. 如果事件没有 `state_key`，拒绝。
    2. 如果发送者的域不匹配 `state_key`，拒绝。
    3. 否则，允许。
5. 如果类型是 `m.room.member`：
    1. 如果没有 `state_key` 属性，或 `content` 中没有 `membership` 属性，拒绝。
    2. 如果 `membership` 是 `join`：
        1. 如果唯一的上一个事件是 `m.room.create` 并且 `state_key` 是创建者，允许。
        2. 如果 `sender` 不与 `state_key` 匹配，拒绝。
        3. 如果 `sender` 被禁止，拒绝。
        4. 如果 `join_rule` 是 `invite` 则允许如果成员状态是 `invite` 或 `join`。
        5. 如果 `join_rule` 是 `public`，允许。
        6. 否则，拒绝。
    3. 如果 `membership` 是 `invite`：
        1. 如果 `content` 有 `third_party_invite` 属性：
            1. 如果 _目标用户_ 被禁止，拒绝。
            2. 如果 `content.third_party_invite` 没有 `signed` 属性，拒绝。
            3. 如果 `signed` 没有 `mxid` 和 `token` 属性，拒绝。
            4. 如果 `mxid` 不与 `state_key` 匹配，拒绝。
            5. 如果当前房间状态中没有与 `token` 匹配 `state_key` 的 `m.room.third_party_invite` 事件，拒绝。
            6. 如果 `sender` 不与 `m.room.third_party_invite` 的 `sender` 匹配，拒绝。
            7. 如果 `signed` 中的任何签名与 `m.room.third_party_invite` 事件中的任何公共密钥匹配，允许。公共密钥在 `m.room.third_party_invite` 的 `content` 中：
                1. 在 `public_key` 属性中单独的公共密钥。
                2. 在 `public_keys` 属性中的公共密钥列表。
            8. 否则，拒绝。
        2. 如果发送者的当前成员状态不是 `join`，拒绝。
        3. 如果目标用户的当前成员状态是 `join` 或 `ban`，拒绝。
        4. 如果发送者的权限等级大于或等于 _邀请等级_，允许。
        5. 否则，拒绝。
    4. 如果 `membership` 是 `leave`：
        1. 如果发送者与 `state_key` 匹配，只有当该用户当前的成员状态是 `invite` 或 `join` 时才允许。
        2. 如果发送者的当前成员状态不是 `join`，拒绝。
        3. 如果目标用户的当前成员状态是 `ban`，且发送者的权限等级小于 _ban 等级_，拒绝。
        4. 如果发送者的权限等级大于或等于 _kick 等级_，且目标用户的权限等级小于发送者的权限等级，允许。
        5. 否则，拒绝。
    5. 如果 `membership` 是 `ban`：
        1. 如果发送者的当前成员状态不是 `join`，拒绝。
        2. 如果发送者的权限等级大于或等于 _ban 等级_，且目标用户的权限等级小于发送者的权限等级，允许。
        3. 否则，拒绝。
    6. 否则，成员为未知。拒绝。
6. 如果发送者的当前成员状态不是 `join`，拒绝。
7. 如果类型是 `m.room.third_party_invite`：
    1. 只有当发送者的当前权限等级大于或等于 _invite 等级_ 时才允许。
8. 如果事件类型的 _required power level_ 大于发送者的权限等级，拒绝。
9. 如果事件有一个以 `@` 开头且不与发送者匹配的 `state_key`，拒绝。
10. 如果类型是 `m.room.power_levels`：
    1. 如果 `content` 中的 `users` 属性不是一个有效用户ID并且值为整数（或是字符串表示的整数）的对象，拒绝。
    2. 如果房间中没有之前的 `m.room.power_levels` 事件，允许。
    3. 检查 `users_default`，`events_default`，`state_default`，`ban`，`redact`，`kick`，`invite` 属性是否被添加、修改或删除。对于每个发现的变化：
        1. 如果当前值大于发送者的当前权限等级，拒绝。
        2. 如果新值大于发送者的当前权限等级，拒绝。
    4. 对于 `events` 属性中的每个更改或删除的条目：
        1. 如果当前值大于发送者的当前权限等级，拒绝。
    5. 对于 `events` 属性中每个被添加或更改的条目：
        1. 如果新值大于发送者的当前权限等级，拒绝。
    6. 对于 `users` 属性中除 `sender` 自己的条目外被更改或删除的每个条目：
        1. 如果当前值大于或等于发送者的当前权限等级，拒绝。
    7. 对于 `users` 属性中每个被添加或更改的条目：
        1. 如果新值大于发送者的当前权限等级，拒绝。
    8. 否则，允许。
11. 否则，允许。

> [!info] 信息：
> 这些规则的一些后果：
>
> - 除非您是房间的成员，否则唯一允许的操作（除了初始创建/加入）是：加入公共房间；接受或拒绝房间邀请。
> - 要取消禁令，您必须拥有大于或等于踢出 _和_ 禁止等级 _和_ 大于目标用户权限等级的权限等级。

### 从v2未更改[](https://spec.matrix.org/v1.11/rooms/v3/#unchanged-from-v2)

以下部分自v2以来未修改，但为了完整性包含在内。

#### 修订[](https://spec.matrix.org/v1.11/rooms/v3/#redactions)

在收到修订事件后，服务器必须去除不在以下列表中的任何键：

- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `prev_state`
- `auth_events`
- `origin`
- `origin_server_ts`
- `membership`

内容对象也必须去除所有键，除非它是以下事件类型之一：

- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember) 允许键 `membership`。
- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate) 允许键 `creator`。
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules) 允许键 `join_rule`。
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 允许键 `ban`，`events`，`events_default`，`kick`，`redact`，`state_default`，`users`，`users_default`。
- [`m.room.aliases`](https://spec.matrix.org/v1.11/client-server-api#historical-events) 允许键 `aliases`。
- [`m.room.history_visibility`](https://spec.matrix.org/v1.11/client-server-api#mroomhistory_visibility) 允许键 `history_visibility`。

#### 状态解析[](https://spec.matrix.org/v1.11/rooms/v3/#state-resolution)

事件 _E_ 后的房间状态 _S′(E)_ 是以事件 _E_ 前的房间状态 _S(E)_ 为基础定义的，且取决于 _E_ 是否是状态事件或消息事件：

- 如果 _E_ 是一个消息事件，那么 _S′(E)_ = _S(E)_。
- 如果 _E_ 是一个状态事件，那么 _S′(E)_ 是 _S(E)_，但其条目对应的 `event_type` 和 `state_key` 被 _E_ 的 `event_id` 替换。

事件 _E_ 前的房间状态 _S(E)_ 是事件 _E_ 的 `prev_event`{_E_1, _E_2, ...} 之后的状态 {_S′(E_1_), _S′(E_2_), ...} 的 _解析_。状态集的解析在下面的算法中给出。

##### 定义[](https://spec.matrix.org/v1.11/rooms/v3/#definitions)

版本2房间的状态解析算法使用以下定义，给定房间状态集 {_S_1, _S_2, ...}：

**权限事件。** 权限事件是一种 `m.room.power_levels` 或 `m.room.join_rules` 类型的状态事件，或者一条 `membership` 为 `leave` 或 `ban` 且 `sender` 不匹配 `state_key` 的 `m.room.member` 类型的状态事件。其背后的想法是权限事件可能移除某人在房间中执行某些操作的能力。

**未冲突的状态映射和冲突的状态集合。** 状态映射 _Si_ 的键是`(event_type, state_key)`格式的字符串二元组。值 _V_ 是状态事件。所有状态映射 _Si_ 的键值对 (_K_, _V_) 可以被划分为两个集合。如果给定键 _K_ 在每个 _Si_ 中都具有相同的值 _V_，那么对 (_K_, _V_) 属于未冲突的状态映射。否则，_V_ 属于冲突的状态集合。

注意未冲突的状态映射每个键 _K_ 只匹配一个事件，而冲突的状态集合可能包含多个相同键的事件。

**认证链。** 事件 _E_ 的认证链是包含事件 _E_ 的所有认证事件、它们的所有认证事件等的集合，递归地延续到房间的开始。换句话说，这些是能够通过事件的 `auth_events` 链行走的事件。

**认证差异。** 认证差异首先计算每个状态 _S__i_ 的完整认证链，即每一个事件在 _S__i_ 中的认证链的并集，再移除每个认证链中没有出现的事件。如果 _C__i_ 是 _S__i_ 的完整认证链，那么认证差异是 ∪ _C__i_ - ∩ _C__i_。

**完整冲突集。** 完整冲突集是冲突状态集合和认证差异的并集。

**反向拓扑权限排序。** 一组事件的反向拓扑权限排序是基于认证事件形成的DAG以字典序最小的拓扑排序。反向拓扑权限排序从最早的事件到最晚。为了比较两个拓扑排序以确定哪个是字典序最小，使用如下的事件比较关系：对于事件 _x_ 和 _y_，_x_ < _y_ 当：

1. _x_ 的发送者的权限等级高于 _y_ 的发送者，在查看其相应的 `auth_event` 时；或者
2. 发送者具有相同的权限等级，但 _x_ 的 `origin_server_ts` 小于 _y_ 的 `origin_server_ts`；或者
3. 发送者具有相同的权限等级并且事件具有相同的 `origin_server_ts`，但 _x_ 的 `event_id` 小于 _y_ 的 `event_id`。

可以通过使用Kahn算法进行拓扑排序，且在每一步选择所有候选顶点中依据上述比较关系的最小顶点，找到反向拓扑权限排序。

**主线排序。** 令 _P_ = _P_0 为一个 `m.room.power_levels` 事件。 从 _i_ = 0 开始，反复获取 _P__i_+1，_Pi_ 具有在其 `auth_events` 中的 `m.room.power_levels` 事件。递增 _i_ 并重复直到 _Pi_ 在其 `auth_events` 中没有 `m.room.power_levels` 事件。主线 _P_0 是通过这种方式获取的事件列表 [_P_0 , _P_1, ..., _Pn_]。

令 _e_ = _e0_ 是另一个事件（可能是另一个 `m.room.power_levels` 事件）。可以计算一个相似的事件列表 [_e_1, ..., _em_]，其中 _e__j_+1 是 _ej_ 的 `auth_events` 中的 `m.room.power_levels` 事件并且 _em_ 在其 `auth_events` 中没有 `m.room.power_levels` 事件。(注意我们开始的事件，_e0_，不包括在该列表中，注意它可能为空，因为 _e_ 可能在其 `auth_events` 中根本未引用 `m.room.power_levels` 事件。)

现在比较这两个列表如下。

- 找出最小索引 _j_ ≥ 1，该索引使得 _ej_ 属于 _P_ 的主线。
- 如果这样的 _j_ 存在，那么 _ej_ = _Pi_ 对于一些唯一索引 _i_ ≥ 0。否则设置 _i_ = ∞ ，其中 ∞ 是一个大于所有整数的哨兵值。
- 在这两种情况下，_e_ 的主线位置是 _i_。

由 _P_ 计算的主线位置。基于 _P_ 的一组事件的主线排序是从最小到最大排序，使用如下的事件比较关系：对于事件 _x_ 和 _y_，_x_ < _y_ 当：

1. _x_ 的主线位置比 _y_ 的主线位置大(即 _x_ 的认证链基于一个比 _y_ 早的事件)；或者
2. 事件的主线位置相同，但 _x_ 的 `origin_server_ts` 小于 _y_ 的 `origin_server_ts`；或者
3. 事件的主线位置相同并且事件具有相同的 `origin_server_ts`，但 _x_ 的 `event_id` 小于 _y_ 的 `event_id`。

**迭代认证检查。** 迭代授权检查算法接收一个初始房间状态和一个有序状态事件列表作为输入，并通过对事件列表迭代并在事件受[授权规则](https://spec.matrix.org/v1.11/server-server-api#authorization-rules)允许下，将其应用于房间状态，来构建一个新的房间状态。 如果事件未被授权规则允许，则事件会被忽略。如果检查授权规则所需的 `(event_type, state_key)` 键在状态中不存在，则会使用事件的 `auth_events` 中的相应状态事件，若该授权事件未被拒绝。

##### 算法[](https://spec.matrix.org/v1.11/rooms/v3/#algorithm)

状态集的解析如下求得：

1. 选择出现在完整冲突集中所有权限事件的集合 _X_。对于每个这样的权限事件 _P_，通过添加属于完整冲突集的 _P_ 认证链中的事件放大 _X_。使用反向拓扑权限排序对 _X_ 排序为列表。
2. 从未冲突状态映射开始，并对前一步骤的事件列表应用迭代授权检查算法以获得部分解析的状态。
3. 取所有在第1步中未选中的剩余事件，并根据步骤2中获得的部分解析状态中的权限等级对其进行主线排序。
4. 应用迭代授权检查算法在部分解析状态和前一步的事件列表上。
5. 更新结果通过替换任何事件为未冲突状态映射中相同键的事件，如果这样的事件存在，则获得最终解析的状态。

##### 拒绝事件[](https://spec.matrix.org/v1.11/rooms/v3/#rejected-events)

因为基于事件状态而非认证链的认证失败而被拒绝的事件通常按算法处理，除非另有说明。

由于无法通过该事件的认证链进行认证而拒绝的事件不应在过程中出现，因为它们不应出现在状态中（算法仅使用出现在状态集中或状态集中事件认证链中的事件）。

> [!info] 理念：
> 这有助于确保不同服务器的状态视图更可能收敛，因为事件的拒绝状态可能不同。这种情况发生在一个第三服务器在服务器通过它加入房间时提供错误状态版本时（无论是由于故障还是恶意）。状态的收敛是一种理想的属性，因为它确保房间中的所有用户拥有（大体上）一致的房间状态视图。如果不同服务器上的状态视图分歧，则可能导致房间的分裂，例如：服务器在房间中是否有人问题上意见不合。
>
> 从直觉上讲，使用拒绝的事件感觉很危险，然而：
>
> 1. 服务器不能随意编造状态，因为它们仍需要通过基于事件认证链的授权检查（例如：如果它们之前没有权限等级，它们无法授予自己权限等级）。
> 2. 要使之前拒绝的事件通过授权，必须有一组状态允许该事件。 因此恶意服务器可以生成一个分叉，声称状态是这组特定状态，复制该拒绝事件指向该分叉并发送事件。由此生成的重复事件将通过授权检查。因此，忽略拒绝事件并不会消除任何潜在的攻击向量。

拒绝的认证事件在迭代认证检查中故意不被使用，因为认证事件在迭代认证检查期间不会再被认证(尽管非认证事件会)。

#### 规范JSON[](https://spec.matrix.org/v1.11/rooms/v3/#canonical-json)

服务器不得严格执行在 [附录](https://spec.matrix.org/v1.11/appendices#canonical-json)中指定的 JSON 格式，出于那里描述的原因。

## 房间版本 4

这个房间版本基于[版本 3](https://spec.matrix.org/v1.11/rooms/v3)构建，使用不同的编码来为事件 ID 编码。

### 客户端注意事项[](https://spec.matrix.org/v1.11/rooms/v4/#client-considerations)

该房间版本更改了发送给客户端的事件 ID 的格式。客户端应已经将事件 ID 视为不透明的标识符，不应关心它们的格式。客户端在将事件 ID 包含在请求路径中时仍应对其进行编码。

客户端应该预料到事件 ID 的格式从 `$randomstring:example.org` 更改为类似 `$Rqnc-F-dvnEYJTyHq_iKxU2bZ1CI92-kuZq3a5lr5Zg` 的格式（注意缺少域名）。

尽管在这个房间版本中未更改，实现修订算法的客户端应参考下面的 [修订](https://spec.matrix.org/v1.11/rooms/v4/#redactions) 部分进行完整概述。

### 服务器实施组件[](https://spec.matrix.org/v1.11/rooms/v4/#server-implementation-components)

> [!warning] 警告：
> 此节中的信息只为服务器实施者准备。使用客户端-服务器 API 的应用程序通常不受这里复杂因素的影响。上节关于客户端注意事项是客户端-服务器 API 用例应参考的资源。

房间版本4使用了在[房间版本3](https://spec.matrix.org/v1.11/rooms/v3)定义的相同算法，但使用 URL 安全的 base64 来生成事件 ID。

#### 事件 IDs[](https://spec.matrix.org/v1.11/rooms/v4/#event-ids)

> [!info] 理念：
> 房间版本3生成的事件 ID 使得未编码事件 ID 的客户端实现难以在那些房间中运行。此外，由于 `/` 字符被某些反向代理软件不同解释，它额外引起了关注，并且通常增加了管理难度。

事件 ID 是该事件的 [引用哈希](https://spec.matrix.org/v1.11/server-server-api#calculating-the-reference-hash-for-an-event)，通过一种使用 `-` 和 `_` 替换 `+` 和 `/` 的未填充 Base64 的变种编码。这与 [RFC4648 的 URL 安全 base64 定义](https://tools.ietf.org/html/rfc4648#section-5)相匹配。

事件 ID 仍然以 `$` 开头，可能表现为类似 `$Rqnc-F-dvnEYJTyHq_iKxU2bZ1CI92-kuZq3a5lr5Zg` 的样子。

### 从v3未更改[](https://spec.matrix.org/v1.11/rooms/v4/#unchanged-from-v3)

以下部分自v3以来未修改，但为了完整性包含在内。

#### 修订[](https://spec.matrix.org/v1.11/rooms/v4/#redactions)

在收到修订事件后，服务器必须去除不在以下列表中的任何键：
- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `prev_state`
- `auth_events`
- `origin`
- `origin_server_ts`
- `membership`

内容对象也必须去除所有键，除非它是以下事件类型之一：

- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember) 允许键 `membership`。
- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate) 允许键 `creator`。
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules) 允许键 `join_rule`。
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 允许键 `ban`，`events`，`events_default`，`kick`，`redact`，`state_default`，`users`，`users_default`。
- [`m.room.aliases`](https://spec.matrix.org/v1.11/client-server-api#historical-events) 允许键 `aliases`。
- [`m.room.history_visibility`](https://spec.matrix.org/v1.11/client-server-api#mroomhistory_visibility) 允许键 `history_visibility`。

#### 处理修订[](https://spec.matrix.org/v1.11/rooms/v4/#handling-redactions)

在房间版本 1 和 2 中，修订明确是 [授权规则](https://spec.matrix.org/v1.11/rooms/v1/#authorization-rules) 中规则 11 的一部分。 从房间版本 3 开始，这些条件不再存在，如 [该版本的授权规则](https://spec.matrix.org/v1.11/rooms/v4/#authorization-rules) 所述。

虽然授权规则始终接受修订，但它们不应发送给客户端，直到修订事件和受其影响的事件均被接收并得到验证。如果两个事件都有效并已被服务器看到，则服务器在以下条件之一满足时应用修订：

1. 修订事件的 `sender` 的权限等级大于或等于 _修订等级_。
2. 修订事件的 `sender` 的域与原事件的 `sender` 的域匹配。

如果服务器会应用修订，修订事件也会发送给客户端。否则，服务器只是等待有效的配对事件到达，然后重新检查上述条件。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v4/#event-format)

事件格式与[房间版本 3](https://spec.matrix.org/v1.11/rooms/v3#event-format)相同，不过以下示例中的事件ID已更新，以反映此版本中的更改。

该版本房间中的事件具有以下结构：

##### `持久数据单元`

---

房间版本4及其以后版本的持久数据单元（事件）。

|持久数据单元|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`auth_events`|`[string]`|**必填：**<br><br>允许此事件进入房间的授权事件的事件ID。<br><br>必须包含最多不超过10个事件。请注意，如果使用了相关的授权事件选择规则，则不应该遇到此限制。|
|`content`|`object`|**必填：** 事件的内容。|
|`depth`|`integer`|**必填：** `prev_events` 的最大深度加一。必须小于整数的最大值 (2^63 - 1)。如果房间的深度已达到上限，则深度必须设置为限制值。|
|`hashes`|[事件哈希](https://spec.matrix.org/v1.11/rooms/v4/#definition-persistent-data-unit_event-hash)|**必填：** PDU 的内容哈希，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`origin_server_ts`|`integer`|**必填：** 该事件在来源家庭服务器上被创建的时间戳，以毫秒为单位。|
|`prev_events`|`[string]`|**必填：**<br><br>在创建此事件时所知房间中最近事件的事件ID。<br><br>必须包含最多不超过20个事件。|
|`redacts`|`string`|对于修订事件，要修订的事件的ID。|
|`room_id`|`string`|**必填：** 房间标识符。|
|`sender`|`string`|**必填：** 发送该事件的用户ID。|
|`signatures`|`{string: {string: string}}`|**必填：** PDU 的签名，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`state_key`|`string`|如果此键存在，则事件为状态事件，并将替换先前房间状态中具有相同 `type` 和 `state_key` 的事件。|
|`type`|`string`|**必填：** 事件类型|
|`unsigned`|[未签名数据](https://spec.matrix.org/v1.11/rooms/v4/#definition-persistent-data-unit_unsigneddata)|由来源服务器添加的附加数据但不在 `signatures` 覆盖之内。|

|事件哈希|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`sha256`|`string`|**必填：** 哈希。|

|未签名数据|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`age`|`integer`|此消息发送后经过的毫秒数。|

###### 示例

```json
{
  "auth_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "redacts": "$some-old_event",
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

##### 已弃用的事件内容结构[](https://spec.matrix.org/v1.11/rooms/v4/#deprecated-event-content-schemas)

发送到此版本房间的事件可以具有不同于其正常结构的格式。这些情况在这里进行记录。

> [!warning] 警告：
> 此处描述的行为是为了严格的向后兼容性而保留的。家庭服务器应采取合理的措施防止用户发送这些所谓的“格式错误”的事件，并且绝不应依赖于此处描述的行为作为默认行为。

###### `m.room.power_levels` 事件接受字符串形式的值[](https://spec.matrix.org/v1.11/rooms/v4/#mroompower_levels-events-accept-values-as-strings)

为了保持与早期实现的向后兼容， [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 事件中的每个整数值属性都可以编码为字符串而不是整数。这包括 `events`、`notifications` 和 `users` 属性中的嵌套值。例如，在此房间版本中，以下是有效的 `m.room.power_levels` 事件：

```json
{
  "content": {
    "ban": "50",
    "events": {
      "m.room.power_levels": "100"
    },
    "events_default": "0",
    "state_default": "50",
    "users": {
      "@example:localhost": "100"
    },
    "users_default": "0"
  },
  "origin_server_ts": 1432735824653,
  "room_id": "!jEsUZKDJdhlrceRyVU:example.org",
  "sender": "@example:example.org",
  "state_key": "",
  "type": "m.room.power_levels"
}
```

当值代表一个整数时，它们必须符合以下格式：

- 单个十进制整数，不允许浮点值或小数点，可以有任意数量的前导零（`"100"`，`"000100"`）；
- 可以在整数前加一个单一的 `-` 或 `+` 字符（`"+100"`，`"-100"`）。
- 可以有任意数量的前导或尾随空白字符（`" 100 "`，`" 00100 "`，`" +100 "`，`" -100 "`）。

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v4/#authorization-rules)

在房间版本1和2中，事件需要来自 `event_id` 域的签名才能被视为有效。此房间版本在联邦中不包含 `event_id`，因此不需要该服务器的签名。然而，事件仍然必须由 `sender` 属性指定的服务器签名。

影响授权的状态事件类型包括：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 当未明确提供时，权限级别从默认值推断。例如，提到 `sender` 的权限级别也可以指房间中用户的默认权限级别。

截至房间版本3的完整规则列表如下：

1. 如果类型是 `m.room.create`：
    1. 如果有任何 `prev_events`，拒绝。
    2. 如果 `room_id` 的域与 `sender` 的域不匹配，拒绝。
    3. 如果 `content.room_version` 存在且不是已识别的版本，拒绝。
    4. 如果 `content` 没有 `creator` 属性，拒绝。
    5. 否则，允许。
2. 考虑事件的 `auth_events`：
    1. 如果对于给定的 `type` 和 `state_key` 对有重复条目，拒绝。
    2. 如果有条目的 `type` 和 `state_key` 不符合服务器规范中描述的[授权事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法指定的内容，拒绝。
    3. 如果有条目在[接收PDU时执行的检查](https://spec.matrix.org/v1.11/server-server-api/#checks-performed-on-receipt-of-a-pdu)中被拒绝，拒绝。
    4. 如果条目中没有 `m.room.create` 事件，拒绝。
3. 如果房间状态中的 `m.room.create` 事件的 `content` 属性 `m.federate` 设置为 `false`，且事件的 `sender` 域与创建事件的 `sender` 域不匹配，拒绝。
4. 如果类型是 `m.room.aliases`：
    1. 如果事件没有 `state_key`，拒绝。
    2. 如果发送者的域与 `state_key` 不匹配，拒绝。
    3. 否则，允许。
5. 如果类型是 `m.room.member`：
    1. 如果没有 `state_key` 属性，或 `content` 中没有 `membership` 属性，拒绝。
    2. 如果 `membership` 是 `join`：
        1. 如果唯一的前一个事件是 `m.room.create` 且 `state_key` 是创建者，允许。
        2. 如果 `sender` 不匹配 `state_key`，拒绝。
        3. 如果 `sender` 被禁止，拒绝。
        4. 如果 `join_rule` 是 `invite`，则允许如果成员状态是 `invite` 或 `join`。
        5. 如果 `join_rule` 是 `public`，允许。
        6. 否则，拒绝。
    3. 如果 `membership` 是 `invite`：
        1. 如果 `content` 有 `third_party_invite` 属性：
            1. 如果 _目标用户_ 被禁止，拒绝。
            2. 如果 `content.third_party_invite` 没有 `signed` 属性，拒绝。
            3. 如果 `signed` 没有 `mxid` 和 `token` 属性，拒绝。
            4. 如果 `mxid` 不匹配 `state_key`，拒绝。
            5. 如果当前房间状态中没有 `state_key` 匹配 `token` 的 `m.room.third_party_invite` 事件，拒绝。
            6. 如果 `sender` 不匹配 `m.room.third_party_invite` 的 `sender`，拒绝。
            7. 如果 `signed` 中的任何签名与 `m.room.third_party_invite` 事件中的任何公钥匹配，允许。公钥在 `m.room.third_party_invite` 的 `content` 中，以以下形式：
                1. `public_key` 属性中的单个公钥。
                2. `public_keys` 属性中的公钥列表。
            8. 否则，拒绝。
        2. 如果 `sender` 的当前成员状态不是 `join`，拒绝。
        3. 如果 _目标用户_ 的当前成员状态是 `join` 或 `ban`，拒绝。
        4. 如果 `sender` 的权限级别大于或等于 _邀请级别_，允许。
        5. 否则，拒绝。
    4. 如果 `membership` 是 `leave`：
        1. 如果 `sender` 匹配 `state_key`，允许且仅当该用户的当前成员状态是 `invite` 或 `join`。
        2. 如果 `sender` 的当前成员状态不是 `join`，拒绝。
        3. 如果 _目标用户_ 的当前成员状态是 `ban`，且 `sender` 的权限级别小于 _禁止级别_，拒绝。
        4. 如果 `sender` 的权限级别大于或等于 _踢出级别_，且 _目标用户_ 的权限级别小于 `sender` 的权限级别，允许。
        5. 否则，拒绝。
    5. 如果 `membership` 是 `ban`：
        1. 如果 `sender` 的当前成员状态不是 `join`，拒绝。
        2. 如果 `sender` 的权限级别大于或等于 _禁止级别_，且 _目标用户_ 的权限级别小于 `sender` 的权限级别，允许。
        3. 否则，拒绝。
    6. 否则，成员状态未知。拒绝。
6. 如果 `sender` 的当前成员状态不是 `join`，拒绝。
7. 如果类型是 `m.room.third_party_invite`：
    1. 仅当 `sender` 的当前权限级别大于或等于 _邀请级别_ 时允许。
8. 如果事件类型的 _所需权限级别_ 大于 `sender` 的权限级别，拒绝。
9. 如果事件有一个以 `@` 开头且不匹配 `sender` 的 `state_key`，拒绝。
10. 如果类型是 `m.room.power_levels`：
    1. 如果 `content` 中的 `users` 属性不是一个具有有效用户ID键和整数（或表示整数的字符串）值的对象，拒绝。
    2. 如果房间中没有先前的 `m.room.power_levels` 事件，允许。
    3. 对于属性 `users_default`，`events_default`，`state_default`，`ban`，`redact`，`kick`，`invite` 检查它们是否被添加、更改或删除。对于每个发现的更改：
        1. 如果当前值大于 `sender` 的当前权限级别，拒绝。
        2. 如果新值大于 `sender` 的当前权限级别，拒绝。
    4. 对于在 `events` 属性中被更改或删除的每个条目：
        1. 如果当前值大于 `sender` 的当前权限级别，拒绝。
    5. 对于在 `events` 属性中被添加或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权限级别，拒绝。
    6. 对于在 `users` 属性中被更改或删除的每个条目，除了 `sender` 自己的条目：
        1. 如果当前值大于或等于 `sender` 的当前权限级别，拒绝。
    7. 对于在 `users` 属性中被添加或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权限级别，拒绝。
    8. 否则，允许。
11. 否则，允许。

> [!info] 信息：
> 这些规则的一些后果：
> 
> - 除非您是房间的成员，否则唯一允许的操作（除了初始创建/加入）是：加入一个公共房间；接受或拒绝房间邀请。
> - 要取消对某人的禁止，您必须拥有大于或等于踢出 _和_ 禁止级别的权限级别，_并且_ 大于目标用户的权限级别。

#### 状态解析[](https://spec.matrix.org/v1.11/rooms/v4/#state-resolution)

事件 _E_ 之后的房间状态 _S′(E)_ 是根据事件 _E_ 之前的房间状态 _S(E)_ 定义的，并取决于 _E_ 是状态事件还是消息事件：

- 如果 _E_ 是消息事件，则 _S′(E)_ = _S(E)_。
- 如果 _E_ 是状态事件，则 _S′(E)_ 是 _S(E)_，但其对应于 _E_ 的 `event_type` 和 `state_key` 的条目被 _E_ 的 `event_id` 替换。

事件 _E_ 之前的房间状态 _S(E)_ 是事件 _E_ 的 `prev_event` {_E_1, _E_2, …} 之后状态 {_S′(E_1_), _S′(E_2_), …} 的 _解析_。状态集的解析由以下算法给出。

##### 定义[](https://spec.matrix.org/v1.11/rooms/v4/#definitions)

版本2房间的状态解析算法使用以下定义，给定房间状态集 {_S_1, _S_2, …}：

**权限事件。** 权限事件是类型为 `m.room.power_levels` 或 `m.room.join_rules` 的状态事件，或者是类型为 `m.room.member` 且 `membership` 为 `leave` 或 `ban` 且 `sender` 不匹配 `state_key` 的状态事件。其背后的想法是权限事件可能会移除某人在房间中执行某些操作的能力。

**无冲突状态映射和冲突状态集。** 状态映射 _Si_ 的键是形式为 _K_ = `(event_type, state_key)` 的字符串二元组。值 _V_ 是状态事件。所有状态映射 _Si_ 中的键值对 (_K_, _V_) 可以分为两个集合。如果给定键 _K_ 在每个 _Si_ 中都存在且在每个状态映射中具有相同的值 _V_，则对 (_K_, _V_) 属于 _无冲突状态映射_。否则，_V_ 属于 _冲突状态集_。

请注意，无冲突状态映射对于每个键 _K_ 只有一个事件，而冲突状态集可能包含具有相同键的多个事件。

**授权链。** 事件 _E_ 的授权链是一个集合，包含所有 _E_ 的授权事件，所有 _它们的_ 授权事件，依此类推，递归地回溯到房间的开始。换句话说，这些是通过事件的 `auth_events` 链接行走图可到达的事件。

**授权差异。** 授权差异通过首先计算每个状态 _S__i_ 的完整授权链来计算，即每个事件在 _S__i_ 中的授权链的并集，然后取每个授权链中未出现的事件。如果 _C__i_ 是 _S__i_ 的完整授权链，则授权差异是 ∪ _C__i_ − ∩ _C__i_。

**完整冲突集。** 完整冲突集是冲突状态集和授权差异的并集。

**逆拓扑权限排序。** 一组事件的逆拓扑权限排序是基于授权事件形成的DAG的字典序最小拓扑排序。逆拓扑权限排序从最早的事件到最新的事件排序。为了比较两个拓扑排序以确定哪个是字典序最小的，使用以下事件比较关系：对于事件 _x_ 和 _y_，_x_ < _y_ 如果

1. _x_ 的发送者在其各自的 `auth_event` 中的权限级别比 _y_ 的发送者高；或者
2. 发送者具有相同的权限级别，但 _x_ 的 `origin_server_ts` 小于 _y_ 的 `origin_server_ts`；或者
3. 发送者具有相同的权限级别且事件具有相同的 `origin_server_ts`，但 _x_ 的 `event_id` 小于 _y_ 的 `event_id`。

逆拓扑权限排序可以通过使用Kahn算法进行拓扑排序来找到，并在每一步中选择所有候选顶点中最小的顶点，使用上述比较关系。

**主线排序。** 设 _P_ = _P_0 是一个 `m.room.power_levels` 事件。从 _i_ = 0 开始，反复获取 _P__i_+1，即 _Pi_ 的 `auth_events` 中的 `m.room.power_levels` 事件。递增 _i_ 并重复，直到 _Pi_ 的 `auth_events` 中没有 `m.room.power_levels` 事件。_P_0 的主线是以这种方式获取的事件列表 [_P_0, _P_1, …, _Pn_]。

设 _e_ = _e0_ 是另一个事件（可能是另一个 `m.room.power_levels` 事件）。我们可以计算一个类似的事件列表 [_e_1, …, _em_]，其中 _e__j_+1 是 _ej_ 的 `auth_events` 中的 `m.room.power_levels` 事件，并且 _em_ 的 `auth_events` 中没有 `m.room.power_levels` 事件。（注意我们开始的事件 _e0_ 不包含在此列表中。还要注意它可能是空的，因为 _e_ 可能在其 `auth_events` 中根本没有引用 `m.room.power_levels` 事件。）

现在按如下方式比较这两个列表。

- 找到最小的索引 _j_ ≥ 1，使得 _ej_ 属于 _P_ 的主线。
- 如果存在这样的 _j_，则 _ej_ = _Pi_ 对于某个唯一的索引 _i_ ≥ 0。否则设置 _i_ = ∞，其中 ∞ 是一个大于任何整数的哨兵值。
- 在两种情况下，_e_ 的主线位置是 _i_。

根据从 _P_ 计算的主线位置，基于 _P_ 的一组事件的主线排序是从小到大的排序，使用以下事件比较关系：对于事件 _x_ 和 _y_，_x_ < _y_ 如果

1. _x_ 的主线位置大于 _y_ 的主线位置（即 _x_ 的授权链基于主线中早于 _y_ 的事件）；或者
2. 事件的主线位置相同，但 _x_ 的 `origin_server_ts` 小于 _y_ 的 `origin_server_ts`；或者
3. 事件的主线位置相同且事件具有相同的 `origin_server_ts`，但 _x_ 的 `event_id` 小于 _y_ 的 `event_id`。

**迭代授权检查。** 迭代授权检查算法以初始房间状态和排序的状态事件列表为输入，通过遍历事件列表并应用状态事件到房间状态来构建新的房间状态，如果状态事件被授权规则允许。如果状态事件不被授权规则允许，则忽略该事件。如果用于检查授权规则的 `(event_type, state_key)` 键在状态中不存在，则使用事件的 `auth_events` 中的适当状态事件（如果授权事件未被拒绝）。

##### 算法[](https://spec.matrix.org/v1.11/rooms/v4/#algorithm)

状态集的解析如下获得：

1. 选择出现在完整冲突集中的所有权限事件的集合 _X_。对于每个这样的权限事件 _P_，通过添加 _P_ 的授权链中也属于完整冲突集的事件来扩大 _X_。使用逆拓扑权限排序将 $X$ 排序为列表。
2. 从无冲突状态映射开始，应用迭代授权检查算法到上一步的事件列表以获得部分解析状态。
3. 取所有在步骤1中未选择的剩余事件，并根据步骤2中获得的部分解析状态中的权限级别按主线排序。
4. 在部分解析状态和上一步的事件列表上应用迭代授权检查算法。
5. 通过用无冲突状态映射中具有相同键的事件替换任何事件（如果存在这样的事件）来更新结果，以获得最终解析状态。

##### 被拒绝的事件[](https://spec.matrix.org/v1.11/rooms/v4/#rejected-events)

由于基于事件状态（而不是基于其授权链）未通过授权而被拒绝的事件，除非另有说明，否则算法会照常处理。

请注意，由于未能通过其授权链进行授权而被拒绝的事件不应出现在过程中，因为它们不应出现在状态中（算法仅使用出现在状态集或状态集中的事件的授权链中的事件）。

> [!info] 理由：
> 这有助于确保不同服务器的状态视图更有可能收敛，因为事件的拒绝状态可能不同。如果第三方服务器在服务器通过它加入房间时提供了不正确的状态版本（无论是由于故障还是恶意），这种情况可能会发生。状态的收敛是一个理想的属性，因为它确保房间中的所有用户对房间状态有一个（大致）一致的视图。如果不同服务器的状态视图分歧，可能会导致房间的分叉，例如服务器对房间中谁的存在存在分歧。
> 
> 直观上，使用被拒绝的事件感觉很危险，然而：
> 
> 1. 服务器不能随意编造状态，因为它们仍然需要通过基于事件授权链的授权检查（例如，如果它们之前没有权限级别，它们不能授予自己权限级别）。
> 2. 要使先前被拒绝的事件通过授权，必须有一组允许该事件的状态。恶意服务器因此可以产生一个分叉，其中它声称状态是该特定状态集，复制被拒绝的事件以指向该分叉，并发送事件。复制的事件随后将通过授权检查。因此，忽略被拒绝的事件不会消除任何潜在的攻击向量。

被拒绝的授权事件故意被排除在迭代授权检查之外，因为在迭代授权检查期间，授权事件不会重新授权（尽管非授权事件会）。

#### 规范JSON[](https://spec.matrix.org/v1.11/rooms/v4/#canonical-json)

服务器不得严格执行[附录](https://spec.matrix.org/v1.11/appendices#canonical-json)中指定的JSON格式，原因如附录中所述。

## 房间版本 5

此房间版本基于[版本 4](https://spec.matrix.org/v1.11/rooms/v4)构建，同时强制执行事件的签名密钥有效期。

### 客户端注意事项[](https://spec.matrix.org/v1.11/rooms/v5/#client-considerations)

此房间版本中没有引入客户端注意事项。实现本地修订算法的客户端应参考下文的[修订](https://spec.matrix.org/v1.11/rooms/v5/#redactions)部分以全面了解算法。

### 服务器实现组件[](https://spec.matrix.org/v1.11/rooms/v5/#server-implementation-components)

> [!warning] 警告：
> 本节中的信息严格适用于服务器实现者。使用客户端-服务器 API 的应用程序通常不受此处复杂性的影响。上面关于客户端注意事项的部分是客户端-服务器 API 用例应参考的资源。

房间版本 5 使用了[房间版本 4](https://spec.matrix.org/v1.11/rooms/v4)中定义的相同算法，确保签名密钥的有效性得到尊重。

#### 签名密钥有效期[](https://spec.matrix.org/v1.11/rooms/v5/#signing-key-validity-period)

在验证事件签名时，服务器必须强制执行来自密钥请求的 `valid_until_ts` 属性至少与正在验证的事件的 `origin_server_ts` 一样大。缺少签名密钥副本的服务器必须尝试通过 [GET /_matrix/key/v2/server](https://spec.matrix.org/v1.11/server-server-api#get_matrixkeyv2server) 或 [POST /_matrix/key/v2/query](https://spec.matrix.org/v1.11/server-server-api#post_matrixkeyv2query) API 获得一个。当使用 `/query` 端点时，服务器必须设置 `minimum_valid_until_ts` 属性以提示公证服务器在适当时尝试刷新密钥。

服务器在确定密钥是否有效时，必须使用 `valid_until_ts` 和未来 7 天中的较小者。这是为了避免攻击者发布一个有效时间很长且无法让主服务器所有者撤销的密钥的情况。

### 自 v4 起未更改[](https://spec.matrix.org/v1.11/rooms/v5/#unchanged-from-v4)

以下部分自 v4 起未修改，但为完整性起见仍包括在内。

#### 修订[](https://spec.matrix.org/v1.11/rooms/v5/#redactions)

收到修订事件后，服务器必须去除不在以下列表中的任何键：

- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `prev_state`
- `auth_events`
- `origin`
- `origin_server_ts`
- `membership`

内容对象也必须去除所有键，除非它是以下事件类型之一：

- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember) 允许键 `membership`。
- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate) 允许键 `creator`。
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules) 允许键 `join_rule`。
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 允许键 `ban`、`events`、`events_default`、`kick`、`redact`、`state_default`、`users`、`users_default`。
- [`m.room.aliases`](https://spec.matrix.org/v1.11/client-server-api#historical-events) 允许键 `aliases`。
- [`m.room.history_visibility`](https://spec.matrix.org/v1.11/client-server-api#mroomhistory_visibility) 允许键 `history_visibility`。

#### 处理修订[](https://spec.matrix.org/v1.11/rooms/v5/#handling-redactions)

在房间版本 1 和 2 中，修订明确是[授权规则](https://spec.matrix.org/v1.11/rooms/v1/#authorization-rules)第 11 条的一部分。从房间版本 3 开始，这些条件不再存在，如[此版本的授权规则](https://spec.matrix.org/v1.11/rooms/v5/#authorization-rules)所示。

虽然授权规则始终接受修订，但在修订事件和修订影响的事件都已接收并可以验证之前，不应将其发送给客户端。如果两个事件都有效且已被服务器看到，则服务器在满足以下条件之一时应用修订：

1. 修订事件的 `sender` 的权限级别大于或等于 _redact level_。
2. 修订事件的 `sender` 的域与原始事件的 `sender` 的域匹配。

如果服务器将应用修订，则修订事件也会发送给客户端。否则，服务器只需等待一个有效的合作事件到达，然后可以重新检查上述条件。

#### 事件 ID[](https://spec.matrix.org/v1.11/rooms/v5/#event-ids)

事件 ID 是事件的[引用哈希](https://spec.matrix.org/v1.11/server-server-api#calculating-the-reference-hash-for-an-event)，使用一种替换第 62 和 63 个字符为 `-` 和 `_` 的[无填充 Base64](https://spec.matrix.org/v1.11/appendices#unpadded-base64)变体进行编码，而不是使用 `+` 和 `/`。这与[RFC4648 的 URL 安全 base64 定义](https://tools.ietf.org/html/rfc4648#section-5)相匹配。

事件 ID 仍然以 `$` 为前缀，可能看起来像 `$Rqnc-F-dvnEYJTyHq_iKxU2bZ1CI92-kuZq3a5lr5Zg`。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v5/#event-format)

此版本房间中的事件具有以下结构：

##### `持久数据单元`

---

房间版本 4 及以上的持久数据单元（事件）。

|持久数据单元|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`auth_events`|`[string]`|**必需：**<br><br>允许此事件在房间中的授权事件的事件 ID。<br><br>必须包含少于或等于 10 个事件。请注意，如果使用相关的授权事件选择规则，则不应遇到此限制。|
|`content`|`object`|**必需：** 事件的内容。|
|`depth`|`integer`|**必需：** `prev_events` 的最大深度加一。必须小于整数的最大值（2^63 - 1）。如果房间的深度已达到限制，则深度必须设置为限制。|
|`hashes`|[事件哈希](https://spec.matrix.org/v1.11/rooms/v5/#definition-persistent-data-unit_event-hash)|**必需：** PDU 的内容哈希，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`origin_server_ts`|`integer`|**必需：** 创建此事件时原始主服务器上的时间戳（毫秒）。|
|`prev_events`|`[string]`|**必需：**<br><br>创建此事件时主服务器已知的房间中最近事件的事件 ID。<br><br>必须包含少于或等于 20 个事件。|
|`redacts`|`string`|对于修订事件，被修订事件的 ID。|
|`room_id`|`string`|**必需：** 房间标识符。|
|`sender`|`string`|**必需：** 发送事件的用户 ID。|
|`signatures`|`{string: {string: string}}`|**必需：** PDU 的签名，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`state_key`|`string`|如果此键存在，则事件为状态事件，并将在房间状态中替换具有相同 `type` 和 `state_key` 的先前事件。|
|`type`|`string`|**必需：** 事件类型|
|`unsigned`|[UnsignedData](https://spec.matrix.org/v1.11/rooms/v5/#definition-persistent-data-unit_unsigneddata)|由原始服务器添加但未被 `signatures` 覆盖的附加数据。|

|事件哈希|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`sha256`|`string`|**必需：** 哈希。|

|UnsignedData|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`age`|`integer`|自此消息发送以来经过的毫秒数。|

###### 示例

```json
{
  "auth_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "redacts": "$some-old_event",
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

##### 已弃用的事件内容模式[](https://spec.matrix.org/v1.11/rooms/v5/#deprecated-event-content-schemas)

发送到此版本房间的事件可以具有不同于其正常模式的格式。这些情况在此记录。

> [!warning] 警告：
> 此处描述的行为仅为向后兼容而保留。主服务器应采取合理的预防措施，以防止用户发送这些所谓的“格式错误”事件，并且绝不应依赖此处描述的行为作为默认行为。

###### `m.room.power_levels` 事件接受字符串形式的值[](https://spec.matrix.org/v1.11/rooms/v5/#mroompower_levels-events-accept-values-as-strings)

为了与早期实现保持向后兼容，`m.room.power_levels` 事件中的每个整数值属性可以编码为字符串而不是整数。这包括 `events`、`notifications` 和 `users` 属性中的嵌套值。例如，以下是此房间版本中有效的 `m.room.power_levels` 事件：

```json
{
  "content": {
    "ban": "50",
    "events": {
      "m.room.power_levels": "100"
    },
    "events_default": "0",
    "state_default": "50",
    "users": {
      "@example:localhost": "100"
    },
    "users_default": "0"
  },
  "origin_server_ts": 1432735824653,
  "room_id": "!jEsUZKDJdhlrceRyVU:example.org",
  "sender": "@example:example.org",
  "state_key": "",
  "type": "m.room.power_levels"
}
```

当值代表一个整数时，它们必须是以下格式：

- 一个单一的十进制整数，没有浮点值或小数点，可以有任意数量的前导零（`"100"`，`"000100"`）；
- 可以在整数前加上一个 `-` 或 `+` 字符（`"+100"`，`"-100"`）。
- 可以有任意数量的前导或尾随空白字符（`" 100 "`，`" 00100 "`，`" +100 "`，`" -100 "`）；

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v5/#authorization-rules)

在房间版本 1 和 2 中，事件需要来自 `event_id` 域的签名才能被视为有效。此房间版本不包括在同样的联邦中 `event_id`，因此不需要来自该服务器的签名。然而，事件仍然必须由 `sender` 属性指定的服务器签名。

影响授权的状态事件类型有：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 当未明确提供时，权限级别从默认值推断。例如，提到 `sender` 的权限级别也可以指房间中用户的默认权限级别。

截至房间版本 3 的完整规则列表如下：

1. 如果类型是 `m.room.create`：
    1. 如果有任何 `prev_events`，拒绝。
    2. 如果 `room_id` 的域与 `sender` 的域不匹配，拒绝。
    3. 如果 `content.room_version` 存在且不是已识别的版本，拒绝。
    4. 如果 `content` 没有 `creator` 属性，拒绝。
    5. 否则，允许。
2. 考虑事件的 `auth_events`：
    1. 如果给定 `type` 和 `state_key` 对有重复条目，拒绝。
    2. 如果有条目其 `type` 和 `state_key` 不匹配服务器规范中描述的[授权事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法指定的那些，拒绝。
    3. 如果有条目本身在[接收 PDU 时执行的检查](https://spec.matrix.org/v1.11/server-server-api/#checks-performed-on-receipt-of-a-pdu)下被拒绝，拒绝。
    4. 如果条目中没有 `m.room.create` 事件，拒绝。
3. 如果房间状态中的 `m.room.create` 事件的 `content` 属性 `m.federate` 设置为 `false`，且事件的 `sender` 域与创建事件的 `sender` 域不匹配，拒绝。
4. 如果类型是 `m.room.aliases`：
    1. 如果事件没有 `state_key`，拒绝。
    2. 如果发送者的域与 `state_key` 不匹配，拒绝。
    3. 否则，允许。
5. 如果类型是 `m.room.member`：
    1. 如果没有 `state_key` 属性，或 `content` 中没有 `membership` 属性，拒绝。
    2. 如果 `membership` 是 `join`：
        1. 如果唯一的先前事件是 `m.room.create` 且 `state_key` 是创建者，允许。
        2. 如果 `sender` 不匹配 `state_key`，拒绝。
        3. 如果 `sender` 被禁止，拒绝。
        4. 如果 `join_rule` 是 `invite`，则允许如果成员状态是 `invite` 或 `join`。
        5. 如果 `join_rule` 是 `public`，允许。
        6. 否则，拒绝。
    3. 如果 `membership` 是 `invite`：
        1. 如果 `content` 有 `third_party_invite` 属性：
            1. 如果 _目标用户_ 被禁止，拒绝。
            2. 如果 `content.third_party_invite` 没有 `signed` 属性，拒绝。
            3. 如果 `signed` 没有 `mxid` 和 `token` 属性，拒绝。
            4. 如果 `mxid` 不匹配 `state_key`，拒绝。
            5. 如果当前房间状态中没有 `state_key` 匹配 `token` 的 `m.room.third_party_invite` 事件，拒绝。
            6. 如果 `sender` 不匹配 `m.room.third_party_invite` 的 `sender`，拒绝。
            7. 如果 `signed` 中的任何签名与 `m.room.third_party_invite` 事件中的任何公钥匹配，允许。公钥在 `m.room.third_party_invite` 的 `content` 中：
                1. `public_key` 属性中的单个公钥。
                2. `public_keys` 属性中的公钥列表。
            8. 否则，拒绝。
        2. 如果 `sender` 的当前成员状态不是 `join`，拒绝。
        3. 如果 _目标用户_ 的当前成员状态是 `join` 或 `ban`，拒绝。
        4. 如果 `sender` 的权限级别大于或等于 _invite level_，允许。
        5. 否则，拒绝。
    4. 如果 `membership` 是 `leave`：
        1. 如果 `sender` 匹配 `state_key`，允许当且仅当该用户的当前成员状态是 `invite` 或 `join`。
        2. 如果 `sender` 的当前成员状态不是 `join`，拒绝。
        3. 如果 _目标用户_ 的当前成员状态是 `ban`，且 `sender` 的权限级别小于 _ban level_，拒绝。
        4. 如果 `sender` 的权限级别大于或等于 _kick level_，且 _目标用户_ 的权限级别小于 `sender` 的权限级别，允许。
        5. 否则，拒绝。
    5. 如果 `membership` 是 `ban`：
        1. 如果 `sender` 的当前成员状态不是 `join`，拒绝。
        2. 如果 `sender` 的权限级别大于或等于 _ban level_，且 _目标用户_ 的权限级别小于 `sender` 的权限级别，允许。
        3. 否则，拒绝。
    6. 否则，成员状态未知。拒绝。
6. 如果 `sender` 的当前成员状态不是 `join`，拒绝。
7. 如果类型是 `m.room.third_party_invite`：
    1. 仅当 `sender` 的当前权限级别大于或等于 _invite level_ 时允许。
8. 如果事件类型的 _required power level_ 大于 `sender` 的权限级别，拒绝。
9. 如果事件有一个以 `@` 开头且不匹配 `sender` 的 `state_key`，拒绝。
10. 如果类型是 `m.room.power_levels`：
    1. 如果 `content` 中的 `users` 属性不是一个键为有效用户 ID 且值为整数（或字符串形式的整数）的对象，拒绝。
    2. 如果房间中没有先前的 `m.room.power_levels` 事件，允许。
    3. 对于 `users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`、`invite` 属性，检查它们是否被添加、更改或删除。对于每个发现的更改：
        1. 如果当前值大于 `sender` 的当前权限级别，拒绝。
        2. 如果新值大于 `sender` 的当前权限级别，拒绝。
    4. 对于 `events` 属性中被更改或删除的每个条目：
        1. 如果当前值大于 `sender` 的当前权限级别，拒绝。
    5. 对于 `events` 属性中被添加或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权限级别，拒绝。
    6. 对于 `users` 属性中被更改或删除的每个条目，除了 `sender` 自己的条目：
        1. 如果当前值大于或等于 `sender` 的当前权限级别，拒绝。
    7. 对于 `users` 属性中被添加或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权限级别，拒绝。
    8. 否则，允许。
11. 否则，允许。

> [!info] 信息：
> 这些规则的一些后果：
> 
> - 除非您是房间的成员，否则唯一允许的操作（除了初始创建/加入）是：加入公共房间；接受或拒绝房间邀请。
> - 要取消对某人的禁令，您必须具有大于或等于踢出和禁令级别的权限级别，并且大于目标用户的权限级别。

#### 状态解析[](https://spec.matrix.org/v1.11/rooms/v5/#state-resolution)

事件 _E_ 之后的房间状态 _S′(E)_ 是根据事件 _E_ 之前的房间状态 _S(E)_ 定义的，并且取决于 _E_ 是状态事件还是消息事件：

- 如果 _E_ 是消息事件，则 _S′(E)_ = _S(E)_。
- 如果 _E_ 是状态事件，则 _S′(E)_ 是 _S(E)_，但其对应于 _E_ 的 `event_type` 和 `state_key` 的条目被 _E_ 的 `event_id` 替换。

事件 _E_ 之前的房间状态 _S(E)_ 是事件 _E_ 的 `prev_event` {_E_1, _E_2, …} 之后的状态集合 {_S′(E_1), _S′(E_2), …} 的 _解析_。状态集合的解析由以下算法给出。

##### 定义[](https://spec.matrix.org/v1.11/rooms/v5/#definitions)

版本 2 房间的状态解析算法使用以下定义，给定房间状态集合 {_S_1, _S_2, …}：

**权限事件。** 权限事件是类型为 `m.room.power_levels` 或 `m.room.join_rules` 的状态事件，或类型为 `m.room.member` 且 `membership` 为 `leave` 或 `ban` 且 `sender` 不匹配 `state_key` 的状态事件。其背后的想法是权限事件是可能会移除某人在房间中做某事的能力的事件。

**无冲突状态映射和冲突状态集合。** 状态映射 _Si_ 的键是形式为 _K_ = `(event_type, state_key)` 的字符串二元组。值 _V_ 是状态事件。所有状态映射 _Si_ 中的键值对 (_K_, _V_) 可以分为两个集合。如果给定键 _K_ 在每个 _Si_ 中都存在且在每个状态映射中具有相同的值 _V_，则对 (_K_, _V_) 属于 _无冲突状态映射_。否则，_V_ 属于 _冲突状态集合_。

请注意，无冲突状态映射每个键 _K_ 只有一个事件，而冲突状态集合可能包含具有相同键的多个事件。

**授权链。** 事件 _E_ 的授权链是一个集合，包含 _E_ 的所有授权事件、它们的所有授权事件，依此类推，递归地回溯到房间的开始。换句话说，这些是通过事件的 `auth_events` 链接诱导的图遍历可达的事件。

**授权差异。** 授权差异通过首先计算每个状态 _S_i_ 的完整授权链来计算，即每个事件在 _S_i_ 中的授权链的并集，然后取出每个授权链中不存在的每个事件。如果 _C_i_ 是 _S_i_ 的完整授权链，则授权差异是 ∪_C_i_ − ∩_C_i_。

**完整冲突集合。** 完整冲突集合是冲突状态集合和授权差异的并集。

**反向拓扑权限排序。** 一组事件的反向拓扑权限排序是基于授权事件形成的 DAG 的字典序最小拓扑排序。反向拓扑权限排序从最早的事件到最新的事件排序。为了比较两个拓扑排序以确定哪个是字典序最小，使用以下事件比较关系：对于事件 _x_ 和 _y_，如果 _x_ 的发送者在各自的 `auth_event` 中具有更高的权限级别，则 _x_ < _y_；或者发送者具有相同的权限级别，但 _x_ 的 `origin_server_ts` 小于 _y_ 的 `origin_server_ts`；或者发送者具有相同的权限级别且事件具有相同的 `origin_server_ts`，但 _x_ 的 `event_id` 小于 _y_ 的 `event_id`。

反向拓扑权限排序可以通过使用 Kahn 算法进行拓扑排序来找到，并在每一步中选择所有候选顶点中最小的顶点，使用上述比较关系。

**主线排序。** 令 _P_ = _P_0 是一个 `m.room.power_levels` 事件。从 _i_ = 0 开始，重复获取 _P_i+1，即 _P_i_ 的 `auth_events` 中的 `m.room.power_levels` 事件。递增 _i_ 并重复，直到 _P_i_ 的 `auth_events` 中没有 `m.room.power_levels` 事件。_P_0 的主线是以这种方式获取的事件列表 [_P_0, _P_1, …, _P_n]。

令 _e_ = _e_0 是另一个事件（可能是另一个 `m.room.power_levels` 事件）。我们可以计算一个类似的事件列表 [_e_1, …, _e_m]，其中 _e_j+1 是 _e_j_ 的 `auth_events` 中的 `m.room.power_levels` 事件，并且 _e_m_ 的 `auth_events` 中没有 `m.room.power_levels` 事件。（请注意，我们开始的事件 _e_0 不包含在此列表中。还要注意，它可能是空的，因为 _e_ 可能根本没有在其 `auth_events` 中引用 `m.room.power_levels` 事件。）

现在按如下方式比较这两个列表。

- 找到最小的索引 _j_ ≥ 1，使得 _e_j_ 属于 _P_ 的主线。
- 如果存在这样的 _j_，则 _e_j_ = _P_i_，对于某个唯一的索引 _i_ ≥ 0。否则设置 _i_ = ∞，其中 ∞ 是大于任何整数的哨兵值。
- 在这两种情况下，_e_ 的主线位置是 _i_。

根据 _P_ 计算的主线位置，基于 _P_ 的一组事件的主线排序是从小到大的排序，使用以下事件比较关系：对于事件 _x_ 和 _y_，如果 _x_ 的主线位置大于 _y_ 的主线位置（即 _x_ 的授权链基于主线中早于 _y_ 的事件），则 _x_ < _y_；或者事件的主线位置相同，但 _x_ 的 `origin_server_ts` 小于 _y_ 的 `origin_server_ts`；或者事件的主线位置相同且事件具有相同的 `origin_server_ts`，但 _x_ 的 `event_id` 小于 _y_ 的 `event_id`。

**迭代授权检查。** 迭代授权检查算法以初始房间状态和排序的状态事件列表作为输入，通过遍历事件列表并应用状态事件到房间状态来构建新的房间状态，如果状态事件被[授权规则](https://spec.matrix.org/v1.11/server-server-api#authorization-rules)允许。如果状态事件不被授权规则允许，则忽略该事件。如果检查授权规则所需的 `(event_type, state_key)` 键不在状态中，则使用事件的 `auth_events` 中的适当状态事件（如果授权事件未被拒绝）。

##### 算法[](https://spec.matrix.org/v1.11/rooms/v5/#algorithm)

状态集合的解析如下获得：

1. 选择出现在完整冲突集合中的所有权限事件的集合 _X_。对于每个这样的权限事件 _P_，通过添加 _P_ 的授权链中也属于完整冲突集合的事件来扩大 _X_。使用反向拓扑权限排序将 $X$ 排序为列表。
2. 应用迭代授权检查算法，从无冲突状态映射开始，对上一步的事件列表进行部分解析状态。
3. 取所有未在步骤 1 中选择的剩余事件，并根据步骤 2 中获得的部分解析状态中的权限级别按主线排序。
4. 对部分解析状态和上一步的事件列表应用迭代授权检查算法。
5. 更新结果，通过用无冲突状态映射中具有相同键的事件替换任何事件（如果存在这样的事件），以获得最终解析状态。

##### 被拒绝的事件[](https://spec.matrix.org/v1.11/rooms/v5/#rejected-events)

由于基于事件状态的授权失败而被拒绝的事件（而不是基于其授权链）通常由算法处理，除非另有说明。

请注意，由于未能通过其授权链进行授权而被拒绝的事件不应出现在过程中，因为它们不应出现在状态中（算法仅使用出现在状态集合或状态集合中事件的授权链中的事件）。

> [!info] 理由：
> 这有助于确保不同服务器的状态视图更有可能收敛，因为事件的拒绝状态可能不同。这可能发生在第三方服务器在服务器通过它加入房间时提供不正确的状态版本（由于故障或恶意）。状态的收敛是一个理想的属性，因为它确保房间中的所有用户对房间状态有一个（大致）一致的视图。如果不同服务器的状态视图发生分歧，可能会导致房间的分叉，例如服务器对房间中谁的存在意见不一致。
> 
> 直观上，使用被拒绝的事件感觉很危险，然而：
> 
> 1. 服务器不能随意编造状态，因为它们仍然需要通过基于事件授权链的授权检查（例如，如果之前没有权限级别，它们不能授予自己权限级别）。
> 2. 要使先前被拒绝的事件通过授权，必须有一组允许该事件的状态。恶意服务器因此可以产生一个分叉，其中它声称状态是该特定状态集，复制被拒绝的事件以指向该分叉，并发送事件。复制的事件将通过授权检查。因此，忽略被拒绝的事件不会消除任何潜在的攻击向量。

被拒绝的授权事件故意排除在迭代授权检查中使用，因为授权事件在迭代授权检查期间不会重新授权（尽管非授权事件会）。

#### 规范 JSON [](https://spec.matrix.org/v1.11/rooms/v5/#canonical-json)

服务器不得严格执行[附录](https://spec.matrix.org/v1.11/appendices#canonical-json)中指定的 JSON 格式，原因如附录所述。

## 房间版本 6

此房间版本基于[版本5](https://spec.matrix.org/v1.11/rooms/v5)，同时更改了对事件执行的各种授权规则。

### 客户端注意事项[](https://spec.matrix.org/v1.11/rooms/v6/#client-considerations)

此房间版本未引入客户端注意事项。实现本地修订算法的客户端应参考下面的[修订](https://spec.matrix.org/v1.11/rooms/v6/#redactions)部分以获取算法的完整概述。

#### 修订[](https://spec.matrix.org/v1.11/rooms/v6/#redactions)

**[此版本新增]** `m.room.aliases` 的所有重要含义已从修订算法中移除。其余规则与过去的房间版本相同。

收到修订事件时，服务器必须去除任何不在以下列表中的键：

- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `prev_state`
- `auth_events`
- `origin`
- `origin_server_ts`
- `membership`

内容对象也必须去除所有键，除非它是以下事件类型之一：

- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember) 允许键 `membership`。
- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate) 允许键 `creator`。
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules) 允许键 `join_rule`。
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 允许键 `ban`、`events`、`events_default`、`kick`、`redact`、`state_default`、`users`、`users_default`。
- [`m.room.history_visibility`](https://spec.matrix.org/v1.11/client-server-api#mroomhistory_visibility) 允许键 `history_visibility`。

### 服务器实现组件[](https://spec.matrix.org/v1.11/rooms/v6/#server-implementation-components)

> [!warning] 警告：
> 本节中的信息仅供服务器实现者使用。使用客户端-服务器API的应用程序通常不受此处包含的复杂性影响。上面关于客户端注意事项的部分是客户端-服务器API用例应参考的资源。

房间版本6对[房间版本5](https://spec.matrix.org/v1.11/rooms/v5)中描述的算法进行了以下更改。

#### 修订[](https://spec.matrix.org/v1.11/rooms/v6/#redactions-1)

[见上文](https://spec.matrix.org/v1.11/rooms/v6/#redactions)。

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v6/#authorization-rules)

**[此版本新增]** 删除了与 `m.room.aliases` 类型事件相关的规则4。`m.room.aliases` 事件仍然必须通过与状态事件相关的授权检查。

**[此版本新增]** 此外，`m.room.power_levels` 类型事件的授权规则现在在 `content` 下包含一个 `notifications` 属性。这更新了规则10.4和10.5（现在是9.4和9.5），这些规则检查 `events` 属性。

事件必须由 `sender` 属性指定的服务器签名。

影响授权的状态事件类型有：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 当未明确提供时，权限级别从默认值推断。例如，提到 `sender` 的权限级别也可以指房间中用户的默认权限级别。

> [!info] 信息：
> `m.room.redaction` 事件与任何其他事件一样受授权规则约束。实际上，这意味着它们通常会被授权规则允许，除非 `m.room.power_levels` 事件通过 `events` 或 `events_default` 属性为 `m.room.redaction` 事件设置权限级别要求。特别是，修订级别不被授权规则考虑。
> 
> 发送修订事件的能力并不意味着修订本身应该被执行。接收服务器必须执行额外的检查，如[处理修订](https://spec.matrix.org/v1.11/rooms/v6/#handling-redactions)部分所述。

规则如下：

1. 如果类型是 `m.room.create`：
    1. 如果有任何 `prev_events`，拒绝。
    2. 如果 `room_id` 的域名与 `sender` 的域名不匹配，拒绝。
    3. 如果 `content.room_version` 存在且不是已识别的版本，拒绝。
    4. 如果 `content` 没有 `creator` 属性，拒绝。
    5. 否则，允许。
2. 如果事件有 `auth_events`：
    1. 对于给定的 `type` 和 `state_key` 对有重复条目，拒绝。
    2. 条目的 `type` 和 `state_key` 不符合服务器规范中描述的[认证事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法，拒绝。
3. 如果事件的 `auth_events` 中没有 `m.room.create`，拒绝。
4. 如果类型是 `m.room.member`：
    1. 如果没有 `state_key` 属性，或 `content` 中没有 `membership` 属性，拒绝。
    2. 如果 `membership` 是 `join`：
        1. 如果唯一的前一个事件是 `m.room.create` 且 `state_key` 是创建者，允许。
        2. 如果 `sender` 不匹配 `state_key`，拒绝。
        3. 如果 `sender` 被禁止，拒绝。
        4. 如果 `join_rule` 是 `invite`，则允许如果会员状态是 `invite` 或 `join`。
        5. 如果 `join_rule` 是 `public`，允许。
        6. 否则，拒绝。
    3. 如果 `membership` 是 `invite`：
        1. 如果 `content` 有 `third_party_invite` 属性：
            1. 如果 _目标用户_ 被禁止，拒绝。
            2. 如果 `content.third_party_invite` 没有 `signed` 属性，拒绝。
            3. 如果 `signed` 没有 `mxid` 和 `token` 属性，拒绝。
            4. 如果 `mxid` 不匹配 `state_key`，拒绝。
            5. 如果当前房间状态中没有 `state_key` 匹配 `token` 的 `m.room.third_party_invite` 事件，拒绝。
            6. 如果 `sender` 不匹配 `m.room.third_party_invite` 的 `sender`，拒绝。
            7. 如果 `signed` 中的任何签名匹配 `m.room.third_party_invite` 事件中的任何公钥，允许。公钥在 `m.room.third_party_invite` 的 `content` 中：
                1. 在 `public_key` 属性中是单个公钥。
                2. 在 `public_keys` 属性中是公钥列表。
            8. 否则，拒绝。
        2. 如果 `sender` 的当前会员状态不是 `join`，拒绝。
        3. 如果 _目标用户_ 的当前会员状态是 `join` 或 `ban`，拒绝。
        4. 如果 `sender` 的权限级别大于或等于 _邀请级别_，允许。
        5. 否则，拒绝。
    4. 如果 `membership` 是 `leave`：
        1. 如果 `sender` 匹配 `state_key`，仅当该用户的当前会员状态是 `invite` 或 `join` 时允许。
        2. 如果 `sender` 的当前会员状态不是 `join`，拒绝。
        3. 如果 _目标用户_ 的当前会员状态是 `ban`，且 `sender` 的权限级别小于 _禁止级别_，拒绝。
        4. 如果 `sender` 的权限级别大于或等于 _踢出级别_，且 _目标用户_ 的权限级别小于 `sender` 的权限级别，允许。
        5. 否则，拒绝。
    5. 如果 `membership` 是 `ban`：
        1. 如果 `sender` 的当前会员状态不是 `join`，拒绝。
        2. 如果 `sender` 的权限级别大于或等于 _禁止级别_，且 _目标用户_ 的权限级别小于 `sender` 的权限级别，允许。
        3. 否则，拒绝。
    6. 否则，会员状态未知。拒绝。
5. 如果 `sender` 的当前会员状态不是 `join`，拒绝。
6. 如果类型是 `m.room.third_party_invite`：
    1. 仅当 `sender` 的当前权限级别大于或等于 _邀请级别_ 时允许。
7. 如果事件类型的 _所需权限级别_ 大于 `sender` 的权限级别，拒绝。
8. 如果事件有一个以 `@` 开头且不匹配 `sender` 的 `state_key`，拒绝。
9. 如果类型是 `m.room.power_levels`：
    1. 如果 `content` 中的 `users` 属性不是一个键为有效用户ID且值为整数（或字符串形式的整数）的对象，拒绝。
    2. 如果房间中没有之前的 `m.room.power_levels` 事件，允许。
    3. 对于 `users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`、`invite` 属性，检查它们是否被添加、改变或移除。对于每个发现的更改：
        1. 如果当前值大于 `sender` 的当前权限级别，拒绝。
        2. 如果新值大于 `sender` 的当前权限级别，拒绝。
    4. **[此版本更改]** 对于 `events` 或 `notifications` 属性中被更改或移除的每个条目：
        1. 如果当前值大于 `sender` 的当前权限级别，拒绝。
    5. **[此版本更改]** 对于 `events` 或 `notifications` 属性中被添加或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权限级别，拒绝。
    6. 对于 `users` 属性中被更改或移除的每个条目，除了 `sender` 自己的条目：
        1. 如果当前值大于或等于 `sender` 的当前权限级别，拒绝。
    7. 对于 `users` 属性中被添加或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权限级别，拒绝。
    8. 否则，允许。
10. 否则，允许。

> [!info] 信息：
> 这些规则的一些后果：
> 
> - 除非你是房间的成员，否则唯一允许的操作（除了最初的创建/加入）是：加入一个公共房间；接受或拒绝房间邀请。
> - 要取消对某人的封禁，你必须拥有大于或等于踢出和封禁级别的权限，并且大于目标用户的权限级别。

#### 规范 JSON[](https://spec.matrix.org/v1.11/rooms/v6/#canonical-json)

服务器必须严格执行[附录](https://spec.matrix.org/v1.11/appendices#canonical-json)中规定的 JSON 格式。这在大多数端点上会导致 400 `M_BAD_JSON` 错误，或者在联邦中丢弃事件。例如，联邦 API 的 `/send` 端点会丢弃事件，而客户端服务器 API 的 `/send/{eventType}` 端点会返回 `M_BAD_JSON` 错误。

### 从 v5 未更改[](https://spec.matrix.org/v1.11/rooms/v6/#unchanged-from-v5)

以下部分自 v5 以来未修改，但为了完整性而包括在内。

#### 处理撤销[](https://spec.matrix.org/v1.11/rooms/v6/#handling-redactions)

在房间版本 1 和 2 中，撤销明确是[授权规则](https://spec.matrix.org/v1.11/rooms/v1/#authorization-rules)第 11 条的一部分。从房间版本 3 开始，这些条件不再存在，如[此版本的授权规则](https://spec.matrix.org/v1.11/rooms/v6/#authorization-rules)所示。

虽然授权规则总是接受事件的撤销，但在撤销事件和被撤销事件都被接收并验证之前，不应将其发送给客户端。如果两个事件都是有效的并且已被服务器看到，则服务器在满足以下条件之一时应用撤销：

1. 撤销事件的 `sender` 的权限级别大于或等于撤销级别。
2. 撤销事件的 `sender` 的域与原始事件的 `sender` 的域匹配。

如果服务器将应用撤销，则撤销事件也会发送给客户端。否则，服务器只需等待一个有效的配对事件到达，然后可以重新检查上述条件。

#### 事件 ID[](https://spec.matrix.org/v1.11/rooms/v6/#event-ids)

事件 ID 是事件的[引用哈希](https://spec.matrix.org/v1.11/server-server-api#calculating-the-reference-hash-for-an-event)，使用一种[无填充 Base64](https://spec.matrix.org/v1.11/appendices#unpadded-base64)的变体进行编码，该变体用 `-` 和 `_` 替换第 62 和 63 个字符，而不是使用 `+` 和 `/`。这符合[RFC4648 的 URL 安全 base64 定义](https://tools.ietf.org/html/rfc4648#section-5)。

事件 ID 仍然以 `$` 为前缀，可能看起来像 `$Rqnc-F-dvnEYJTyHq_iKxU2bZ1CI92-kuZq3a5lr5Zg`。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v6/#event-format)

此版本房间中的事件具有以下结构：

##### `持久数据单元`

---

房间版本 4 及以上的持久数据单元（事件）。

|持久数据单元|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`auth_events`|`[string]`|**必需：**<br><br>允许此事件进入房间的授权事件的事件ID。<br><br>必须包含小于或等于10个事件。注意，如果使用相关的授权事件选择规则，则不应遇到此限制。|
|`content`|`object`|**必需：** 事件的内容。|
|`depth`|`integer`|**必需：** `prev_events`的最大深度加一。必须小于整数的最大值（2^63 - 1）。如果房间的深度已经达到限制，则深度必须设置为限制值。|
|`hashes`|[事件哈希](https://spec.matrix.org/v1.11/rooms/v6/#definition-persistent-data-unit_event-hash)|**必需：** PDU的内容哈希，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`origin_server_ts`|`integer`|**必需：** 创建此事件时原始主服务器上的时间戳（毫秒）。|
|`prev_events`|`[string]`|**必需：**<br><br>主服务器在创建此事件时知道的房间中最近事件的事件ID。<br><br>必须包含小于或等于20个事件。|
|`redacts`|`string`|对于修订事件，被修订事件的ID。|
|`room_id`|`string`|**必需：** 房间标识符。|
|`sender`|`string`|**必需：** 发送事件的用户ID。|
|`signatures`|`{string: {string: string}}`|**必需：** PDU的签名，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`state_key`|`string`|如果此键存在，则事件是状态事件，并将替换房间状态中具有相同`type`和`state_key`的先前事件。|
|`type`|`string`|**必需：** 事件类型|
|`unsigned`|[未签名数据](https://spec.matrix.org/v1.11/rooms/v6/#definition-persistent-data-unit_unsigneddata)|由原始服务器添加但未被`signatures`覆盖的附加数据。|

|事件哈希|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`sha256`|`string`|**必需：** 哈希值。|

|UnsignedData|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`age`|`integer`|自此消息发送以来已过去的毫秒数。|

###### 示例

```json
{
  "auth_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "redacts": "$some-old_event",
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

##### 弃用的事件内容架构[](https://spec.matrix.org/v1.11/rooms/v6/#deprecated-event-content-schemas)

发送到此版本房间的事件可能具有与其正常架构不同的格式。这些情况记录在此。

> [!warning] 警告：
> 此处描述的行为仅为了向后兼容而严格保留。主服务器应采取合理的措施，以防止用户发送这些所谓的“格式不当”的事件，并且绝不应该默认依赖于此处描述的行为。

###### `m.room.power_levels`事件接受字符串形式的值[](https://spec.matrix.org/v1.11/rooms/v6/#mroompower_levels-events-accept-values-as-strings)

为了与早期实现保持向后兼容，在`m.room.power_levels`事件中，每个整数值属性可以编码为字符串而不是整数。这包括`events`、`notifications`和`users`属性中的嵌套值。例如，以下是此房间版本中有效的`m.room.power_levels`事件：

```json
{
  "content": {
    "ban": "50",
    "events": {
      "m.room.power_levels": "100"
    },
    "events_default": "0",
    "state_default": "50",
    "users": {
      "@example:localhost": "100"
    },
    "users_default": "0"
  },
  "origin_server_ts": 1432735824653,
  "room_id": "!jEsUZKDJdhlrceRyVU:example.org",
  "sender": "@example:example.org",
  "state_key": "",
  "type": "m.room.power_levels"
}
```

当值表示一个整数时，它们必须以下述格式表示：

- 一个单一的十进制整数，没有浮点值或小数点，前置零可以任意数量（如`"100"`、`"000100"`）；
- 可选择在整数前加一个单一的`-`或`+`字符（如`"+100"`、`"-100"`）。
- 可选择在前面或后面加任意数量的空白字符（如`" 100 "`、`" 00100 "`、`" +100 "`、`" -100 "`）。

#### 状态解析[](https://spec.matrix.org/v1.11/rooms/v6/#state-resolution)

事件_E_之后的房间状态_S′(E)_是以事件_E_之前的房间状态_S(E)_为基础定义的，并取决于事件_E_是状态事件还是消息事件：

- 如果事件_E_是消息事件，则_S′(E)_ = _S(E)_。
- 如果事件_E_是状态事件，则_S′(E)_是_S(E)_，但其对应于事件_E_的`event_type`和`state_key`的条目被事件_E_的`event_id`替换。

事件_E_之前的房间状态_S(E)_是事件_E_的`prev_event`{_E_1, _E_2, …}之后状态集合{_S′(E_1_)_, _S′(E_2_)_, …}的解析。状态集合的解析使用下面的算法给出。

##### 定义[](https://spec.matrix.org/v1.11/rooms/v6/#definitions)

版本2房间的状态解析算法使用以下定义，并给出状态集合{_S_1, _S_2, …}：

**权限事件。** 权限事件是一个具有类型`m.room.power_levels`、`m.room.join_rules`的状态事件，或具有`membership`为`leave`或`ban`且`sender`与`state_key`不匹配的`m.room.member`类型的状态事件。其背后的理念是，权限事件是可能会删除某人在房间中执行某事的能力的事件。

**无冲突状态映射和冲突状态集。** 状态映射_Si_的键是字符串形式的二元组_K_=`(event_type, state_key)`。值_V_是状态事件。所有状态映射_Si_的键值对(_K_, _V_)可以划分为两个集合。如果给定键_K_存在于每个_Si_中，并且在每个状态映射中具有相同的值_V_，则该对(_K_, _V_)属于无冲突状态映射。否则，_V_属于冲突状态集。

请注意，无冲突状态映射对于每个键_K_仅包含一个事件，而冲突状态集可能包含具有相同键的多个事件。

**认证链。** 事件_E_的认证链是一个集合，包含了所有_E_的认证事件及其认证事件递归地向前延伸，直至房间开始。换言之，这些是通过事件的`auth_events`链接形成的图遍历可达的事件。

**认证差异。** 认证差异通过首先计算每个状态_S__i_的完整认证链来计算，即_S__i_中每个事件的认证链的并集，然后筛选出那些未出现在每个认证链中的事件。如果_C__i_是_S__i_的完整认证链，则认证差异是 ∪ _C__i_ −  ∩ _C__i_。

**完整冲突集。** 完整冲突集是冲突状态集和认证差异的并集。

**反向拓扑权限顺序。** 一组事件的反向拓扑权限顺序是基于由认证事件形成的DAG的字典序最小拓扑顺序。反向拓扑权限顺序从最早的事件排列到最新的事件。为了比较两个拓扑顺序以确定哪个是字典顺序最小的，使用以下事件比较关系：对于事件_x_和_y_，_x_ < _y_如下

1. _x_的发送者权限级别比_y_的更高，在各自的`auth_event`中查看；
2. 发送者权限级别相同，但_x_的`origin_server_ts`小于_y_的`origin_server_ts`；
3. 发送者权限级别相同且事件具有相同的`origin_server_ts`，但_x_的`event_id`小于_y_的`event_id`。

反向拓扑权限顺序可以通过使用Kahn算法进行拓扑排序，并在每一步选择候选顶点中最小的顶点来获取。

**主线排序。** 令_P_ = P_0为一个`m.room.power_levels`事件。以_i_ = 0开始，反复获取`_P__i_+1`，即_Pi_的`auth_events`中的`m.room.power_levels`事件。递增_i_并重复，直到_Pi_的`auth_events`中没有`m.room.power_levels`事件为止。_P_0的主线是以这种方式获取的事件列表[_P_0 , _P_1, … , _Pn_]。

让_e_ = e_0是另一个事件（可能是另一个`m.room.power_levels`事件）。我们可以计算出类似的事件列表[_e_1, …, _e_m_]，其中_e__j_+1是_e_j_的`auth_events`中的`m.room.power_levels`事件，且_e_m_的`auth_events`中没有`m.room.power_levels`事件。（请注意，我们开始的事件_e_0不包含在此列表中。此外，由于_e_可能根本没有引用`m.room.power_levels`事件在其`auth_events`中，因此该列表可能为空。）

现在按以下规则比较这两个列表。

- 找到最小的索引_j_ ≥ 1，其中_e_j_属于_P_的主线。
- 如果这样的_j_存在，则_e_j_ = _P_i_对于某个唯一的索引_i_ ≥ 0存在。否则设置_i_为 ∞，其中 ∞ 是一个大于任何整数的哨兵值。
- 在这两种情况下，_e_的主线位置是_i_。

给定从_P_计算的主线位置，基于_P_的事件集合的主线排序是使用以下事件比较关系从小到大的顺序：对于事件_x_和_y_，_x_ < _y_如下

1. _x_的主线位置 **大于** _y_的主线位置（即_x_的认证链基于主线中的较早事件而不是_y_）；
2. 事件的主线位置相同，但_x_的`origin_server_ts`小于_y_的`origin_server_ts`；
3. 事件的主线位置相同且事件具有相同的`origin_server_ts`，但_x_的`event_id`小于_y_的`event_id`。

**迭代认证检查。** 迭代认证检查算法以初始房间状态和排序的状态事件列表作为输入，通过遍历事件列表在符合[授权规则](https://spec.matrix.org/v1.11/server-server-api#authorization-rules)的情况下将状态事件应用于房间状态来构建新的房间状态。如果状态事件不符合授权规则，则该事件会被忽略。如果用于检查授权规则的`(event_type, state_key)`键不存在于状态中，则如果认证事件未被拒绝，使用事件的`auth_events`中的适当状态事件。

##### 算法[](https://spec.matrix.org/v1.11/rooms/v6/#algorithm)

一组状态的解析按如下方式获取：

1. 选择完整冲突集中所有权限事件的集合_X_。对于每个这样的权限事件_P_，通过添加在完整冲突集中属于_P_的认证链中的事件来扩充_X_。按反向拓扑权限顺序将$X$ 排序为列表。
2. 从无冲突状态映射开始，应用迭代认证检查算法到第一步中的事件列表以获得部分解析状态。
3. 取所有在步骤1中未被选择的事件，按基于步骤2中获得的部分解析状态的权限级别的主线排序。
4. 将部分解析状态和上述步骤获得的事件列表应用于迭代认证检查算法。
5. 更新结果，通过替换任何事件为无冲突状态映射中存在的具有相同键的事件（如存在）以获得最终解析状态。

##### 拒绝的事件[](https://spec.matrix.org/v1.11/rooms/v6/#rejected-events)

由于在事件状态中基础上失败的授权而被拒绝的事件（而不是基于其认证链）按通常算法处理，除非另有说明。

请注意，由于认证失败的拒绝事件不应出现在过程中，因为它们不应出现在状态中（算法仅使用状态集中存在的事件或状态集中事件的认证链中的事件）。

> [!info] 原因：
> 这样可以确保不同服务器的状态视图更有可能收敛，因为事件的拒绝状态可能会有所不同。如果第三方服务器在用户加入房间时提供错误版本的状态（无论是故障还是恶意），可能会发生这种情况。状态的收敛性是一个有益的性质，因为这确保了房间中所有用户对房间状态的（大多数）一致视图。如果不同服务器的状态视图分歧，可能会导致房间二分，例如服务器对谁在房间中意见不一。
> 
> 直观上，使用拒绝的事件感觉很危险，但：
> 
> 1. 服务器无法随意构造状态，因为它们仍需通过基于事件认证链的认证检查（例如，它们不能赋予自己之前未曾拥有的权限级别）。
> 2. 为了让先前拒绝的事件通过认证，必须存在一个允许该事件的状态集。恶意服务器因此可能会产生一个分叉，声称状态就是该特定状态集，复制拒绝事件指向该分叉并发送事件。复制的事件将通过认证检查。因此，忽视拒绝的事件不会消除任何潜在的攻击向量。

拒绝的认证事件故意在迭代认证检查中排除使用，因为认证事件不会在迭代认证检查过程中重新认证（尽管非认证事件会）。

#### 签名密钥有效期[](https://spec.matrix.org/v1.11/rooms/v6/#signing-key-validity-period)

在验证事件签名时，服务器必须强制`valid_until_ts`属性值至少与被验证事件的`origin_server_ts`相同。缺失签名密钥的服务器必须通过[GET /_matrix/key/v2/server](https://spec.matrix.org/v1.11/server-server-api#get_matrixkeyv2server)或[POST /_matrix/key/v2/query](https://spec.matrix.org/v1.11/server-server-api#post_matrixkeyv2query) API 尝试获取。如果使用`/query`端点，服务器必须设置“`minimum_valid_until_ts”`属性以促使公证服务器尝试刷新密钥（如适用）。

服务器在确定密钥有效性时必须使用`valid_until_ts`和未来7天中的较小值。这是为了避免攻击者发布长时间有效且没有办法由主服务器所有者撤销的密钥的情况。

## 房间版本 7

此房间版本在[version 6](https://spec.matrix.org/v1.11/rooms/v6)的基础上增加敲门为可能的加入规则和成员状态。

### 客户端注意事项[](https://spec.matrix.org/v1.11/rooms/v7/#client-considerations)

这是首个完全支持敲门的房间版本。因此，用户无法敲门基于v7的房间。

尽管此房间版本未变更，但在本地实现撤销算法的客户端应参考下面的[redactions](https://spec.matrix.org/v1.11/rooms/v7/#redactions)部分以获取完整概述。

### 服务器实现组件[](https://spec.matrix.org/v1.11/rooms/v7/#server-implementation-components)

> [!warning] 警告：
> 本节所提供的信息只适用于服务器实现者。使用客户端-服务器API的应用程序一般不受此处包含的复杂细节影响。上面关于客户端注意事项的章节是与客户端-服务器API来交流的用例应该参考的资源。

房间版本7新增事件授权规则以支持敲门。[房间版本6](https://spec.matrix.org/v1.11/rooms/v6)详细记录了其他授权规则更改，v6是基于这些版本的。

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v7/#authorization-rules)

**【此版本新增】** 检查`m.room.member`事件时，新增一个针对`membership=knock`的检查点。

事件必须由由`sender`属性指定的服务器签名。

影响授权的状态事件类型为：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 没有明确提供时，默认会推导出权限级别。例如，提到`sender`的权限级别也可以指用户在房间中的默认权限级别。

> [!info] 信息：
> `m.room.redaction`事件按照与其他事件相同的方式适用授权规则。实际上，这意味着他们通常会被授权规则允许，除非`m.room.power_levels`事件通过`events`或`events_default`属性为`m.room.redaction`事件设置了权限级别要求。特别是，授权规则不考虑撤销级别。因此，能够发送撤销事件并不意味着应执行撤销。本地服务器必须执行额外检查，如[Handling redactions](https://spec.matrix.org/v1.11/rooms/v7/#handling-redactions)部分所述。

规则如下：

1. 如果类型是`m.room.create`：
    1. 如果存在任何`prev_events`，拒绝。
    2. 如果`room_id`的域名与`sender`的域名不匹配，拒绝。
    3. 如果`content.room_version`存在但不是识别的版本，拒绝。
    4. 如果`content`中没有`creator`属性，拒绝。
    5. 否则，允许。
2. 如果事件有`auth_events`：
    1. 对于给定的`type`和`state_key`对有重复条目，拒绝。
    2. 其条目的`type`和`state_key`不匹配服务器规范中描述的[授权事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法中指定的那些，拒绝。
3. 如果事件在其`auth_events`中没有`m.room.create`，拒绝。
4. 如果类型为`m.room.member`：
    1. 如果没有`state_key`属性或`content`中没有`membership`属性，拒绝。
    2. 如果`membership`是`join`：
        1. 如果只有一个先前事件是`m.room.create`且`state_key`是创建者，允许。
        2. 如果`sender`与`state_key`不匹配，拒绝。
        3. 如果`sender`被封禁，拒绝。
        4. **【此版本更改】** 如果`join_rule`是`invite`或`knock`然后允许成员状态为`invite`或`join`。
        5. 如果`join_rule`是`public`，允许。
        6. 否则，拒绝。
    3. 如果`membership`是`invite`：
        1. 如果`content`有`third_party_invite`属性：
            1. 如果目标用户被封禁，拒绝。
            2. 如果`content.third_party_invite`没有`signed`属性，拒绝。
            3. 如果`signed`没有`mxid`和`token`属性，拒绝。
            4. 如果`mxid`与`state_key`不匹配，拒绝。
            5. 如果当前房间状态中没有`state_key`匹配`token`的`m.room.third_party_invite`事件，拒绝。
            6. 如果`signed`中任何签名与`m.room.third_party_invite`事件中的任何公钥匹配，允许。公钥在`m.room.third_party_invite`的`content`中以以下形式：
                1. `public_key`属性中的单个公钥。
                2. `public_keys`属性中的公钥列表。
            8. 否则，拒绝。
        2. 如果`sender`的当前成员状态不是`join`，拒绝。
        3. 如果目标用户的当前成员状态是`join`或`ban`，拒绝。
        4. 如果`sender`的权限级别大于等于邀请级别，允许。
        5. 否则，拒绝。
    4. 如果`membership`是`leave`：
        1. **【此版本更改】** 如果`sender`与`state_key`匹配，当且仅当该用户的当前成员状态是`invite`、`join`或`knock`时允许。
        2. 如果`sender`的当前成员状态不是`join`，拒绝。
        3. 如果目标用户的当前成员状态是`ban`，而`sender`的权限级别小于封禁级别，拒绝。
        4. 如果`sender`的权限级别大于等于踢出级别，并且目标用户的权限级别小于`sender`的权限级别，允许。
        5. 否则，拒绝。
    5. 如果`membership`是`ban`：
        1. 如果`sender`的当前成员状态不是`join`，拒绝。
        2. 如果`sender`的权限级别大于等于封禁级别，并且目标用户的权限级别小于`sender`的权限级别，允许。
        3. 否则，拒绝。
    6. **【此版本新增】** 如果`membership`是`knock`：
        1. 如果`join_rule`不是`knock`，拒绝。
        2. 如果`sender`与`state_key`不匹配，拒绝。
        3. 如果`sender`的当前成员状态不是`ban`、`invite`或`join`，允许。
        4. 否则，拒绝。
    7. 否则，成员身份未知。拒绝。
5. 如果`sender`的当前成员状态不是`join`，拒绝。
6. 如果类型为`m.room.third_party_invite`：
    1. 当且仅当`sender`的当前权限级别大于等于邀请级别时允许。
7. 如果事件类型所需权限级别大于`sender`的权限级别，拒绝。
8. 如果事件的`state_key`以`@`开头且与`sender`不匹配，拒绝。
9. 如果类型是`m.room.power_levels`：
    1. 如果`content`中的`users`属性不是一个具有有效用户ID为键且值为整数（或字符串表示的整数）对象，拒绝。
    2. 如果房间中没有先前的`m.room.power_levels`事件，允许。
    3. 对于属性`users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`、`invite`检查是否已添加、修改或删除。对于发现的每个更改：
        1. 如果当前值大于`sender`的当前权限级别，拒绝。
        2. 如果新值高于`sender`的当前权限级别，拒绝。
    4. 对于在`events`或`notifications`属性中更改或删除的每个条目：
        1. 如果当前值大于`sender`的当前权限级别，拒绝。
    5. 对于在`events`或`notifications`属性中增加或更改的每个条目：
        1. 如果新值大于`sender`的当前权限级别，拒绝。
    6. 对于在`users`属性中更改或删除的每个条目（除了`sender`自己的条目）：
        1. 如果当前值大于或等于`sender`的当前权限级别，拒绝。
    7. 对于在`users`属性中增加或更改的每个条目：
        1. 如果新值大于`sender`的当前权限级别，拒绝。
    8. 否则，允许。
10. 否则，允许。

> [!info] 信息：
> 这些规则的某些结果：
> 
> - 除非您是房间的成员，否则唯一允许的操作（除了初始创建/加入）是：加入公共房间；接受或拒绝房间的邀请。
> - 要取消某人的封禁，您的权限级别必须大于或等于踢和封禁级别，且大于目标用户的权限级别。

### 从v6不变[](https://spec.matrix.org/v1.11/rooms/v7/#unchanged-from-v6)

以下部分自v6以来未被修改，但为完整性而包括在内。

#### Redactions[](https://spec.matrix.org/v1.11/rooms/v7/#redactions)

接收到撤销事件后，服务器必须剥离任何不在以下列表中的键：

- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `prev_state`
- `auth_events`
- `origin`
- `origin_server_ts`
- `membership`

内容对象还必须剥离所有键，除非它是以下事件类型之一：

- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)允许键`membership`。
- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)允许键`creator`。
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)允许键`join_rule`。
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)允许键`ban`、`events`、`events_default`、`kick`、`redact`、`state_default`、`users`、`users_default`。
- [`m.room.history_visibility`](https://spec.matrix.org/v1.11/client-server-api#mroomhistory_visibility)允许键`history_visibility`。

#### 处理撤销[](https://spec.matrix.org/v1.11/rooms/v7/#handling-redactions)

在房间版本1和2中，撤销被明确地视为[授权规则](https://spec.matrix.org/v1.11/rooms/v1/#authorization-rules)下的第11条。从房间版本3开始，这些条件不再存在，如[此版本的授权规则](https://spec.matrix.org/v1.11/rooms/v7/#authorization-rules)所示。

虽然授权规则总是接受撤销，但在事件撤销和被撤销事件均接收并验证之前不应发送给客户端。如果两事件有效且由服务器看到，则服务器在以下条件之一得到满足时应用撤销：

1. 撤销事件的`sender`的权限级别大于或等于撤销级别。
2. 撤销事件的`sender`域名与原始事件的`sender`域名匹配。

如果服务器应该应用撤销，还将向客户端发送撤销事件。否则，服务器只是等待事件的有效对到达，然后重新检查以上条件。

#### 事件IDs[](https://spec.matrix.org/v1.11/rooms/v7/#event-ids)

事件ID是事件编码的[引用哈希](https://spec.matrix.org/v1.11/server-server-api#calculating-the-reference-hash-for-an-event)，使用一种变体的[无填充Base64](https://spec.matrix.org/v1.11/appendices#unpadded-base64)，其中第62和63个字符用`-`和`_`替代`+`和`/`。这符合[RFC4648对URL安全base64](https://tools.ietf.org/html/rfc4648#section-5)的定义。

事件IDs仍然以`$`为前缀，可能看起来像`$Rqnc-F-dvnEYJTyHq_iKxU2bZ1CI92-kuZq3a5lr5Zg`。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v7/#event-format)

此版本房间中的事件具有以下结构：

##### `持久化数据单元`

---

为房间版本4及其后的版本定义的持久化数据单元（事件）。

|持久化数据单元|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`auth_events`|`[string]`|**必需：**<br><br>允许此事件进入房间的授权事件ID。<br><br>必须包含小于或等于10个事件。注意，如果应用相关的授权事件选择规则，这种限制永远不会遇到。|
|`content`|`object`|**必需：** 事件的内容。|
|`depth`|`integer`|**必需：** `prev_events`的最大深度加一。必须小于整数的最大值(2^63 - 1)。如果房间深度已经达到极限，则深度必须设置为极限。|
|`hashes`|[事件哈希](https://spec.matrix.org/v1.11/rooms/v7/#definition-persistent-data-unit_event-hash)|**必需：** 使用在[Signing Events](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法，PDU的内容哈希。|
|`origin_server_ts`|`integer`|**必需：** 在创建此事件时，由原始主服务器记录的时间戳（以毫秒为单位）。|
|`prev_events`|`[string]`|**必需：**<br><br>当主服务器创建此事件时，房间中主服务器已知的最新事件的ID。<br><br>必须包含小于或等于20个事件。|
|`redacts`|`string`|对于撤销事件而言，被撤销事件的ID。|
|`room_id`|`string`|**必需：** 房间标识符。|
|`sender`|`string`|**必需：** 发送事件的用户ID。|
|`signatures`|`{string: {string: string}}`|**必需：** 使用在[Signing Events](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法，PDU的签名。|
|`state_key`|`string`|如果此键存在，则事件为状态事件，并将替代房间状态中具有相同`type`和`state_key`的先前事件。|
|`type`|`string`|**必需：** 事件类型|
|`unsigned`|[UnsignedData](https://spec.matrix.org/v1.11/rooms/v7/#definition-persistent-data-unit_unsigneddata)|由原始服务器添加的额外数据，但未被`signatures`覆盖。|

|事件哈希|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`sha256`|`string`|**必需：** 哈希值。|

|UnsignedData|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`age`|`integer`|自此消息发送以来已过去的毫秒数。|

###### 示例

```json
{
  "auth_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "redacts": "$some-old_event",
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```


##### 废弃的事件内容模式

发送到这个版本房间的事件可以具有与其正常模式不同的格式。这些情况记录在此。

> [!warning] 警告：
> 这里描述的行为仅为向后兼容而严格保留。家服务器应采取合理的预防措施，以防止用户发送这些所谓的“格式错误”事件，并且绝不能将这些描述的行为用作默认设置。

###### `m.room.power_levels`事件接受字符串形式的值

为了保持与早期实现的向后兼容性，`m.room.power_levels`事件中的每个整数值属性可以编码为字符串而不是整数。这包括在`events`、`notifications`和`users`属性中的嵌套值。例如，以下是此房间版本中的有效`m.room.power_levels`事件：

```json
{
  "content": {
    "ban": "50",
    "events": {
      "m.room.power_levels": "100"
    },
    "events_default": "0",
    "state_default": "50",
    "users": {
      "@example:localhost": "100"
    },
    "users_default": "0"
  },
  "origin_server_ts": 1432735824653,
  "room_id": "!jEsUZKDJdhlrceRyVU:example.org",
  "sender": "@example:example.org",
  "state_key": "",
  "type": "m.room.power_levels"
}
```

当值表示整数时，它们必须符合以下格式：

- 单个十进制整数，不允许小数或小数点，可以有任意数量的前导零（`"100"`，`"000100"`）；
- 可以在整数前面加上一个`-`或`+`符号（`"+100"`，`"-100"`）。
- 可以有任意数量的前导或尾随空白字符（`" 100 "`，`" 00100 "`，`" +100 "`，`" -100 "`）。

#### 状态解析

事件_E_后的房间状态_S′(E)_是根据事件_E_前的房间状态_S(E)_定义的，并取决于_E_是状态事件还是消息事件：

- 如果_E_是消息事件，则_S′(E)_ = _S(E)_。
- 如果_E_是状态事件，则_S′(E)_是_S(E)_，除了其对应于_E_的`event_type`和`state_key`的条目被_E_的`event_id`替换。

事件_E_前的房间状态_S(E)_是_E_的`prev_event`{_E_1, _E_2, …}之后状态集合{_S′(E_1)_, _S′(E_2)_, …}的解析。一个状态集合的解析在以下算法中给出。

##### 定义

版本2房间状态解析算法使用以下定义，给定房间状态集合{_S_1, _S_2, …}：

**权限事件。** 权限事件是类型为`m.room.power_levels`或`m.room.join_rules`的状态事件，或者类型为`m.room.member`且`membership`为`leave`或`ban`且`sender`与`state_key`不匹配的状态事件。其想法是权限事件可能会剥夺某人在房间中执行某些操作的能力。

**无冲突状态映射和冲突状态集合。** 状态映射_Si_的键是形式为_K_ = `(event_type, state_key)`的两个字符串元组。值_V_是状态事件。所有状态映射_Si_的键值对(_K_, _V_)可以分为两个集合。如果某个键_K_出现在每个_Si_中，并且在每个状态映射中的值_V_相同，则对(_K_, _V_)属于无冲突状态映射。否则，_V_属于冲突状态集合。

请注意，无冲突状态映射对于每个键_K_只有一个事件，而冲突状态集合可能包含具有相同键的多个事件。

**验证链。** 事件_E_的验证链是一个集合，包含所有_E_的验证事件，所有_它们_的验证事件，依此类推，递归地追溯到房间的开始。换句话说，这些是通过遍历事件`auth_events`链接所诱导的图形到达的事件。

**验证差异。** 验证差异是通过首先计算每个状态_Si_的完整验证链，即_Si_中每个事件的验证链的并集，然后取每个验证链中未出现的事件来计算的。如果_Ci_是_Si_的完整验证链，则验证差异是∪_Ci_ − ∩_Ci_。

**完整冲突集合。** 完整冲突集合是冲突状态集合和验证差异的并集。

**逆向拓扑权限排序。** 事件集合的逆向拓扑权限排序是基于验证事件形成的有向无环图的按字典顺序最小的拓扑排序。逆向拓扑权限排序从最早的事件到最新的排序。为了比较两个拓扑排序以确定哪个按字典顺序最小，以下事件比较关系用于事件_x_和_y_：_x_ < _y_ 当

1. _x_的发送者在查看他们各自的`auth_event`时拥有比_y_的发送者更高的权限级别时；或
2. 发送者具有相同的权限级别，但_x_的`origin_server_ts`小于_y_的`origin_server_ts`；或
3. 发送者具有相同的权限级别并且事件具有相同的`origin_server_ts`，但_x_的`event_id`小于_y_的`event_id`。

逆向拓扑权限排序可以通过使用拓扑排序的Kahn算法对事件进行排序来找到，在每一步中从所有候选顶点中选择最小的顶点，使用上述比较关系。

**主线排序。** 令_P_ = _P0_为一个`m.room.power_levels`事件。初始_i_ = 0，反复提取`_P_i_+1`, 即授权事件中的`m.room.power_levels`事件，并递增_i_，重复直到_Pi_在其授权事件中没有`m.room.power_levels`事件。主线_P_0是按此方式提取的事件[_P_0, _P_1, …, _Pn_]的列表。

让_e_ = _e0_为另一个事件（可能是另一个`m.room.power_levels`事件）。我们可以计算出类似的事件列表[_e_1, …, _em_]，其中_ei_是_e_的auth_events中的`m.room.power_levels`事件，而_em_在其auth_events中没有`m.room.power_levels`事件。（注意，我们开始的事件_e0_不包含在此列表中。还要注意，它可能是空的，因为_e_可能完全没有在其auth_events中引用`m.room.power_levels`事件。）

现在按如下所示比较这两个列表：

- 查找最小索引_j_ ≥ 1, 使得_ej_属于_P_的主线。
- 如果存在这样的_j_，则_ej_ = _Pi_在某个唯一索引_i_ ≥ 0处。否则设置_i_ = ∞，其中∞是比任何整数都大的哨兵值。
- 在这两种情况下，_e_的主线位置是_i_。

基于_P_计算的主线位置，这些事件集合的主线排序是使用以下事件比较关系，从小到大排序：这是基于哪个事件在主线上更早。

1. _x_的主线位置比_y_大（即_x_的验证链基于主线中比_y_更早的事件）；或
2. 事件的主线位置相同，但_x_的`origin_server_ts`小于_y_的`origin_server_ts`; 或
3. 事件的主线位置相同并且事件具有相同的`origin_server_ts`, 但_x_的`event_id`小于_y_的`event_id`。

以上比对是基于事件的，偏向更高权限、更早时间、更早生成事件作为基准顺序，

**迭代验证检查。** 迭代验证检查算法以初始房间状态和已排序的状态事件列表作为输入，通过遍历事件列表并将状态事件应用于房间状态来构造一个新房间状态，如果状态事件通过[授权规则]。如果状态事件不符合授权规则，则忽略该事件。如果检查授权规则时需要的`(event_type, state_key)`键不在状态中，则使用事件的`auth_events`中的适当状态事件，前提是授权事件未被拒绝。

##### 算法

一组状态的解析如下获得：

1. 选择完整冲突集合中所有权限事件的集合_X_。对于每个这样的权限事件_P_，通过将其授权链中也属于完整冲突集合的事件添加到_X_中来扩展_X_。使用逆向拓扑权限排序将$X$排序为一个列表。
2. 应用迭代验证检查算法，从无冲突状态映射开始，应用从上一步开始事件列表中的事件，以获得部分解析状态。
3. 获取所有剩余的，没有在第1步中被选中的事件，并按照在第2步获得的部分解析状态的权限级别进行主线排序。
4. 将迭代验证检查算法应用于部分解析状态和上一步中的事件列表。
5. 通过替换任何事件和来自无冲突状态映射的相同键的事件，以获得最终解析状态。

##### 被拒事件

由于根据事件状态而不是根据其授权链验证失败而被拒绝的事件通常由算法处理，除非另有说明。

进一步说，不应在过程中出现因验证链失败而被拒绝的事件，因为它们不应出现在状态中（该算法仅使用状态集中出现的事件或状态集中事件的验证链中的事件）。

> [!info] 理由：
> 这有助于确保不同的服务器状态视图更有可能收敛，因为事件的拒绝状态可能不同。例如，如果第三服务器在通过其加入房间时给出了错误的状态版本，则可能发生这种情况（无论是由于故障还是恶意）。状态收敛是一种理想状态，因为它确保房间中所有用户对房间状态有一个（大多数情况下）一致的视图。如果不同服务器的状态视图分歧，可能会导致房间的分裂，因为服务器可能在谁在房间中等问题上产生分歧。
>
> 直观看来，使用被拒绝的事件似乎很危险，但：
>
> 1. 服务器不能随意捏造状态，因为它们仍然需要通过基于事件验证链的验证检查（例如，如果先前没有权限，它们不能授予自己权限级别）。
> 2. 要让以前被拒绝的事件通过验证，必须有一组允许该事件的状态。因此，一台恶意服务器可以生成一个分支，声称该分支的状态是该特定状态集合，复制被拒绝的事件以指向该分支，并发送该事件。复制的事件将通过验证检查。因此，忽略被拒绝的事件不会消除任何潜在的攻击矢量。

被拒绝的验证事件故意不在迭代验证检查中使用，因为验证事件在迭代验证检查期间不会重新验证（虽然非验证事件会重新验证）。

#### 规范JSON

服务器必须严格执行在附录中指定的JSON格式。在大多数端点上，这会转换为400 `M_BAD_JSON` 错误，或者在联邦传播时丢弃事件。例如，Federation API的 `/send` 端点将丢弃事件，而Client Server API的 `/send/{eventType}` 端点将返回 `M_BAD_JSON` 错误。

#### 签名密钥有效期

验证事件签名时，服务器必须确保从密钥请求的`valid_until_ts`属性至少与正在验证的事件的`origin_server_ts`一样大。缺少签名密钥的服务器必须通过[GET /_matrix/key/v2/server](https://spec.matrix.org/v1.11/server-server-api#get_matrixkeyv2server)或[POST /_matrix/key/v2/query](https://spec.matrix.org/v1.11/server-server-api#post_matrixkeyv2query) API尝试获取一个。使用`/query`端点时，服务器必须设置`minimum_valid_until_ts`属性，以提示公证服务器如有适当条件下尝试刷新密钥。

服务器在确定密钥是否有效时，必须使用`valid_until_ts`和未来七天中的较小者。这是为了避免出现攻击者发布一个有效期长的密钥，而家服务器所有者无法撤销它的情况。

## 房间版本 8

此房间版本基于[版本 7](https://spec.matrix.org/v1.11/rooms/v7)引入了一条允许成员基于其他房间的成员资格加入房间的新加入规则。

> [!warning] 警告：
> 此房间版本已知存在与成员加入事件的撤销相关的问题。在创建房间时应优先选择v9而不是v8。

### 客户端注意事项

鼓励客户端在其用户界面中为支持的房间版本公开加入规则选项。

新的加入规则`restricted`在[Client-Server API](https://spec.matrix.org/v1.11/client-server-api/#restricted-rooms)中进行了描述。

在本地实现撤销算法的客户端，应该参考下面的[撤销](https://spec.matrix.org/v1.11/rooms/v8/#redactions)部分以获取完整概述。

#### 撤销

**【此版本中新功能】** `m.room.join_rules`事件在撤销时除了其他键外，还保留`allow`。

> [!warning] 警告：
> [房间版本9](https://spec.matrix.org/v1.11/rooms/v9)增加了与受限房间（v8引入的功能）相关的撤销保护属性的额外情况。在创建新房间时建议优先选择v9而不是v8。

完整的撤销算法如下。

一旦收到撤销事件，服务器必须去除除以下列表中不在的所有键：

- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `prev_state`
- `auth_events`
- `origin`
- `origin_server_ts`
- `membership`

内容对象也必须去除除非它是下列事件类型之一：

- `m.room.member`允许键`membership`。
- `m.room.create`允许键`creator`。
- `m.room.join_rules`允许键`join_rule`、`allow`。
- `m.room.power_levels`允许键`ban`、`events`、`events_default`、`kick`、`redact`、`state_default`、`users`、`users_default`。
- `m.room.history_visibility`允许键`history_visibility`。

### 服务器实现组件

> [!warning] 警告：
> 本节包含的信息严格针对服务器实现者。使用Client-Server API的应用程序通常不受此处包含的复杂性的影响。上面的客户端注意事项部分是Client-Server API用例应参考的资源。

房间版本8增加了一条新加入规则，允许一个房间的成员无需邀请即可加入另一个房间。否则，该房间版本继承了[房间版本7](https://spec.matrix.org/v1.11/rooms/v7)的所有属性。

#### 授权规则

**【此版本新功能】** 在对`m.room.member`事件执行的检查中，增加了处理`content.join_authorised_via_users_server`的新点（规则4.2和4.3.5）。

事件必须由`sender`属性指定的服务器签名。

影响授权的状态事件类型是：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 如果未明确提供，权限级别将从默认值推断。例如，提到`sender`的权限级别也可能指代房间中用户的默认权限级别。

> [!info] 信息：
> `m.room.redaction`事件同其他任何事件一样受授权规则影响。在实践中，这意味着除非`m.room.power_levels`事件通过`events`或`events_default`属性为`m.room.redaction`事件设置权限级别要求，否则它们通常会被授权规则允许。特别是，授权规则**不**考虑撤销级别。
> 
> 发送撤销事件的能力并不意味着撤销本身应该被执行。接收服务器必须执行额外的检查，如[处理撤销](https://spec.matrix.org/v1.11/rooms/v8/#handling-redactions)章节所述。

规则如下：

1. 如果类型是`m.room.create`:
    1. 如果它有任何`prev_events`，拒绝。
    2. 如果`room_id`的域与`sender`的域不匹配，拒绝。
    3. 如果`content.room_version`存在但不是已识别的版本，拒绝。
    4. 如果`content`没有`creator`属性，拒绝。
    5. 否则，允许。
2. 考虑事件的`auth_events`:
    1. 如果某个`type`和`state_key`对的条目重复，拒绝。
    2. 如果某些条目类型和`state_key`未匹配服务器规范中描述的[授权事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法，拒绝。
    3. 如果有被[收到的PDU检查](https://spec.matrix.org/v1.11/server-server-api/#checks-performed-on-receipt-of-a-pdu)拒绝的条目，拒绝。
    4. 如果条目中没有`m.room.create`事件，拒绝。
3. 若`m.room.create`事件在房间状态中有`m.federate`属性设为`false`，且事件的`sender`域与创建事件的`seder`不匹配，拒绝。
4. 如果类型是`m.room.member`:
    1. 如果没有`state_key`，或者`content`中没有`membership`，拒绝。
    2. **【此版本中新功能】** 如果`content`有`join_authorised_via_users_server`属性：
        1. 如果事件未获得用户ID所在的homeserver有效签名，拒绝。
    3. 如果`membership`为`join`:
        1. 如果前一个事件是`m.room.create`并且`state_key`是创建者，则允许。
        2. 如果`sender`与`state_key`不匹配，拒绝。
        3. 如果`sender`被禁止，拒绝。
        4. 如果`join_rule`是`invite`或`knock`，当会员状态是`invite`或`join`时允许。
        5. **【此版本中新功能】** 如果`join_rule`是`restricted`：
            1. 如果会员状态是`join`或`invite`，允许。
            2. 如果`content`中的`join_authorised_via_users_server`键不是邀请其他用户的有足够权限的用户，拒绝。
            3. 否则，允许。
        6. 如果`join_rule`是`public`，允许。
        7. 否则，拒绝。
    4. 如果`membership`为`invite`：
        1. 如果`content`有`third_party_invite`属性：
            1. 如果目标用户被禁用，拒绝。
            2. 如果`content.third_party_invite`没有`signed`属性，拒绝。
            3. 如果`signed`没有`mxid`和`token`属性，拒绝。
            4. 如果`mxid`不匹配`state_key`，拒绝。
            5. 如果当前房间状态中没有与`token`匹配的`m.room.third_party_invite`事件，拒绝。
            6. 如果`sender`与`m.room.third_party_invite`的`snder`不匹配，拒绝。
            7. 如果`signed`中的任何签名与`m.room.third_party_invite`事件中的任何公钥匹配，允许。这些公钥在`m.room.third_party_invite`的`content`中：
                1. `public_key`属性中的单个公钥
                2. `public_keys`属性中的公钥列表
            8. 否则，拒绝。
        2. 如果`sender`的当前会员状态不是`join`，拒绝。
        3. 如果目标用户的当前会员状态是`join`或`ban`，拒绝。
        4. 如果`sender`的权限级别大于或等于邀请级别，允许。
        5. 否则，拒绝。
    5. 如果`membership`为`leave`：
        1. 如果`sender`与`state_key`匹配，并且该用户的当前会员状态是`invite`，`join`或`knock`，允许。
        2. 如果`sender`的当前会员状态不是`join`，拒绝。
        3. 如果目标用户的当前会员状态是`ban`，并且`sender`的权限级别小于禁用级别，拒绝。
        4. 如果`sender`的权限级别大于或等于踢出级别且目标用户的权限级别小于`sender`的权限级别，允许。
        5. 否则，拒绝。
    6. 如果`membership`为`ban`：
        1. 如果`sender`的当前会员状态不是`join`，拒绝。
        2. 如果`sender`的权限级别大于或等于禁用级别并且目标用户的权限级别小于`sender`的权限级别，允许。
        3. 否则，拒绝。
    7. 如果`membership`为`knock`：
        1. 如果`join_rule`不是`knock`，拒绝。
        2. 如果`sender`与`state_key`不匹配，拒绝。
        3. 如果`sender`当前会员状态不是`ban`，`invite`或`join`，允许。
        4. 否则，拒绝。
    8. 否则，成员状态未知。拒绝。
5. 如果`sender`的当前会员状态不是`join`，拒绝。
6. 如果类型是`m.room.third_party_invite`：
    1. 当且仅当`sender`的当前权限级别大于或等于邀请级别时，允许。
7. 如果事件类型的所需权限级别大于`sender`的权限级别，拒绝。
8. 如果事件具有以`@`开头且不匹配`sender`的`state_key`，拒绝。
9. 如果类型是`m.room.power_levels`：
    1. 如果`content`中的`users`属性不是具有有效用户ID为键且值为整数（或整数字符串）的对象，拒绝。
    2. 如果房间中没有先前的`m.room.power_levels`事件，允许。
    3. 检查是否对`users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`、`invite`属性进行了添加、修改或删除。对于每个发现的更改：
        1. 如果当前值高于`sender`的当前权限级别，拒绝。
        2. 如果新值高于`sender`的当前权限级别，拒绝。
    4. 对于在`events`或`notifications`属性中被更改的每个条目或被移除的条目：
        1. 如果当前值大于`sender`的当前权限级别，拒绝。
    5. 对于添加到或在`events`或`notifications`的内容中被更改的每个条目：
        1. 如果新值高于`sender`的当前权限级别，拒绝。
    6. 对于`users`属性中除`sender`自己之外的每次变更或移除：
        1. 如果当前值大于或等于`sender`的当前权限级别，拒绝。
    7. 对于`users`属性中被添加到的或被更改的每个条目：
        1. 如果新值大于`sender`的当前权限级别，拒绝。
    8. 否则，允许。
10. 否则，允许。

> [!info] 信息：
> 这些规则的一些后果：
> - 除非您是房间的成员，否则仅允许的操作（初始创建/加入外）是：加入一个公共房间；接受或拒绝对房间的邀请。
> - 取消用户禁用，您必须拥有等于或高于踢出和禁用级别的权限，而且高于目标用户的权限级别。

#### 撤销

[请参阅上文](https://spec.matrix.org/v1.11/rooms/v8/#redactions)。

### 从v7开始未更改

以下各节自v7以来未修改，但为完整性起见仍提供。

#### 处理撤销

在房间版本1和2中，撤销明确是[授权规则](https://spec.matrix.org/v1.11/rooms/v1/#authorization-rules)规则11的一部分。从房间版本3开始，这些条件不再存在于[此版本的授权规则](https://spec.matrix.org/v1.11/rooms/v8/#authorization-rules)中。

尽管事件的授权规则始终接受撤销，但它们不应发送给客户端，直到撤销事件和受撤销影响的事件都被接收并能被验证。如果这两个事件都是有效的且已被服务器看到，那么当满足以下条件之一时，服务器才能应用撤销：

1. 撤销事件的`sender`的权限级别大于或等于撤销级别。
2. 撤销事件的`sender`的域与原始事件的`sender`的域匹配。

如果服务器要应用撤销，则将撤销事件也发送给客户端。否则，服务器只是在等待有效对方事件到来，然后可以重新检查以上条件。

#### 事件ID

事件ID是事件的[参考哈希](https://spec.matrix.org/v1.11/server-server-api#calculating-the-reference-hash-for-an-event)，使用一种变体的[无填充Base64](https://spec.matrix.org/v1.11/appendices#unpadded-base64)进行编码，该变体使用`-`和`_`替换第62和63个字符而不是使用`+`和`/`。这符合[RFC4648的URL安全base64](https://tools.ietf.org/html/rfc4648#section-5)定义。

事件ID仍以`$`为前缀，可能显示为`$Rqnc-F-dvnEYJTyHq_iKxU2bZ1CI92-kuZq3a5lr5Zg`。

#### 事件格式

此版本房间的事件结构如下：

##### `持久性数据单元`

---

房间版本4及以上的持久性数据单元（事件）。

|持久性数据单元|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`auth_events`|`[string]`|**必需：**<br><br>允许此事件出现在房间中用于授权的事件ID。<br><br>必须包含小于或等于10个事件。注意，如果使用了相关的授权事件选择规则，则该限制不应遇到。|
|`content`|`object`|**必需：** 事件内容。|
|`depth`|`integer`|**必需：** `prev_events`的最大深度加1。必须小于整数的最大值（2^63 - 1）。如果房间的深度已经到达限制，则深度必须设置为该限制。|
|`hashes`|[事件哈希](https://spec.matrix.org/v1.11/rooms/v8/#definition-persistent-data-unit_event-hash)|**必需：** PDU的内容哈希，遵循在[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`origin_server_ts`|`integer`|**必需：** 事件创建时原始服务器上的时间戳（以毫秒为单位）。|
|`prev_events`|`[string]`|**必需：**<br><br>房间中原服务器在创建该事件时知道的最近事件的事件ID。<br><br>必须包含小于或等于20个事件。|
|`redacts`|`string`|对于撤销事件，被撤销事件的ID。|
|`room_id`|`string`|**必需：** 房间标识符。|
|`sender`|`string`|**必需：** 发送事件的用户ID。|
|`signatures`|`{string: {string: string}}`|**必需：** PDU的签名，遵循在[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`state_key`|`string`|如果此键存在，则事件是状态事件，将替换房间状态中具有相同`type`和`state_key`的先前事件。|
|`type`|`string`|**必需：** 事件类型|
|`unsigned`|[UnsignedData](https://spec.matrix.org/v1.11/rooms/v8/#definition-persistent-data-unit_unsigneddata)|由原服务器添加但未被`signatures`覆盖的附加数据。|

|事件哈希|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`sha256`|`string`|**必需：**哈希。|

|未签名数据|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`age`|`integer`|自此消息发送以来经过的毫秒数。|

###### 示例

```json
{
  "auth_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "redacts": "$some-old_event",
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

##### 已弃用的事件内容架构

发送到该版本房间的事件格式可能与其正常架构不同。这些情况在此记录。

> [!warning] 警告：
> 这里描述的行为仅为了向后兼容而保留。家庭服务器应采取合理的预防措施，防止用户发送这些所谓的“格式错误”的事件，并且绝不能将这里描述的行为作为默认依赖。

###### `m.room.power_levels`事件接受作为字符串的值

为了与早期实现保持向后兼容，`m.room.power_levels`事件中的每个整数值属性可以被编码为字符串而不是整数。这包括`events`，`notifications`和`users`属性中的嵌套值。例如，以下是在此房间版本中有效的`m.room.power_levels`事件：

```json
{
  "content": {
    "ban": "50",
    "events": {
      "m.room.power_levels": "100"
    },
    "events_default": "0",
    "state_default": "50",
    "users": {
      "@example:localhost": "100"
    },
    "users_default": "0"
  },
  "origin_server_ts": 1432735824653,
  "room_id": "!jEsUZKDJdhlrceRyVU:example.org",
  "sender": "@example:example.org",
  "state_key": "",
  "type": "m.room.power_levels"
}
```

当值表示整数时，它们必须符合以下格式：

- 单个十进制整数，没有浮点值或小数点，可以选择包含任意数量的前导零（如`"100"`，`"000100"`）；
- 可以选择在整数前加一个单一的`-`或`+`字符（如`"+100"`，`"-100"`）。
- 可以选择包含任意数量的前导或尾随空白字符（如`" 100 "`，`" 00100 "`，`" +100 "`，`" -100 "`）。

#### 状态解析

事件_E_后的房间状态_S′(E)_是根据事件_E_前的房间状态_S(E)_定义的，取决于_E_是状态事件还是消息事件：

- 如果_E_是消息事件，那么_S′(E)_= _S(E)_。
- 如果_E_是状态事件，那么_S′(E)_是_S(E)_，只不过其对应于_E_的`event_type`和`state_key`的条目被_E_的`event_id`替换。

事件_E_前的房间状态_S(E)_是事件_E_的`prev_event`集{_E_1, _E_2,…}之后状态集{_S′(E_1)_, _S′(E_2)_, …}的解析。状态集的解析算法在下文中给出。

##### 定义

对于版本2房间的状态解析算法，给定房间状态集合{_S_1, _S_2, …}，使用以下定义：

**权限事件。** 权限事件是一种状态事件，其类型为`m.room.power_levels`或`m.room.join_rules`，或者是其成员属性为`leave`或`ban`且发送者不匹配state_key的`m.room.member`类型事件。权限事件可能会移除某人在房间中执行某事的能力。

**无冲突状态映射和冲突状态集合。** 状态映射_Si_的键是（event_type, state_key）形式的字符串二元组_K_。值_V_是状态事件。所有状态映射_Si_的键值对(_K_, _V_)可以分为两个集合。如果给定键_K_在每个_Si_中都具有相同的值_V_，则对(_K_, _V_)属于无冲突状态映射。否则，_V_属于冲突状态集合。

需要注意的是，无冲突状态映射对每个键_K_只有一个事件，而冲突状态集合可能包含具有相同键的多个事件。

**授权链。** 事件_E_的授权链是包含所有_E_的授权事件、所有这些授权事件的授权事件，以及如此递归的包含所有事件的集合。这些事件可以通过事件的`auth_events`链接走的图来获得。

**授权差异。** 授权差异通过首先计算每个状态_S_i_的完整授权链，即各事件在_S_i_的授权链的并集，并选取那些不出现在每个授权链中的事件来计算。如果_C_i_是_S_i_的完整授权链，则授权差异是∪_C_i_ - ∩_C_i_。

**完整冲突集合。** 完整冲突集合是冲突状态集合和授权差异的并集。

**反向拓扑权力顺序。** 事件集合的反向拓扑权力顺序是基于授权事件形成的DAG的字典序最小拓扑排序。反向拓扑权力顺序从最早事件排到最新事件。为了比较两个拓扑排序来决定哪一个最小，使用以下事件比较关系：对于事件_x_和_y_，_x_ < _y_当

1. _x_的发送者拥有比_y_的发送者更大的权力等级；
2. 发送者拥有相同的权力等级，但_x_的`origin_server_ts`小于_y_的`origin_server_ts`；
3. 发送者拥有相同的权力等级且事件有相同的`origin_server_ts`，但_x_的`event_id`小于_y_的`event_id`。

反向拓扑权力顺序可以通过使用Kahn的拓扑排序算法来排序事件，且每一步选择最小的顶点使用以上比较关系。

**主线排序。** 令_P_ = _P_0为m.room.power_levels事件。从_i_ = 0开始，不断获取在_P_i_的`auth_events`中的m.room.power_levels事件_P__i+1_。递增_i_并重复，直到_P_i_的`auth_events`中没有m.room.power_levels事件。_P_0的主线是这样的获取的事件列表[_P_0 , _P_1, … , _Pn_]。

令_e_ = _e_0_为另一个事件（可能是另一个m.room.power_levels事件）。我们可以计算相似的事件列表[_e_1, …, _em_]，其中_e__j+1_是在_ej_的`auth_events`中的m.room.power_levels事件且_em_在其`auth_events`中没有这样的事件。（注意我们开始的事件_e0_不包括在这个列表中。也注意它可能是空的，因为_e_可能完全不引用其`auth_events`中的m.room.power_levels事件。）

现在，按如下方式比较这两个列表：

- 找到最小索引_j_，j ≥ 1，使得_ej_属于_P_的主线。
- 如果存在这样的_j_，则_ej_ = _Pi_，对于某个唯一索引_i_ ≥ 0。否则设置_i_ = ∞，其中∞是大于任何整数的哨兵值。
- 在这两种情况下，_e_的主线位置为_i_。

根据从_P_计算的主线位置，基于_P_的一组事件的主线排序是按以下比较关系从小到大的排序：对于事件_x_和_y_，_x_ < _y_当

1. _x_的主线位置大于_y_的主线位置（即_x_的授权链基于主线中的更早事件）；
2. 事件的主线位置相同，但_x_的`origin_server_ts`小于_y_的`origin_server_ts`；
3. 事件的主线位置相同且事件有相同的`origin_server_ts`，但_x_的`event_id`小于_y_的`event_id`。

**迭代授权检查。** 迭代授权检查算法以初始房间状态和已排序的状态事件列表为输入，通过遍历事件列表并根据[授权规则](https://spec.matrix.org/v1.11/server-server-api#authorization-rules)应用状态事件来构建新房间状态。如果状态事件未通过授权规则，则该事件将被忽略。如果缺少检查授权规则所需的(event_type, state_key)键，则使用事件的`auth_events`中的适当状态事件（如果授权事件没有被拒绝，则使用授权事件）。

##### 算法

状态集的解析算法如下：

1. 选择出现在完整冲突集合中的所有权限事件集合_X_。对于每个这样的权限事件_P_，通过添加属于完整冲突集合的授权链的事件来扩大_X_并对_X_使用反向拓扑权力排序。
2. 应用迭代授权检查算法，从无冲突状态映射开始，对上一步的事件列表应用以获得部分解析状态。
3. 获取所有未在第1步选择的事件并按第2步中获得的部分解析状态中的权力等级排序。
4. 对部分解析状态和前一步的事件列表应用迭代授权检查算法。
5. 通过用无冲突状态映射中具有相同键的事件替换任何事件来更新结果（如果此类事件存在），以获得最终解析状态。

##### 拒绝的事件

因基于事件状态而不是其授权链状态的授权失败而被拒绝的事件按常规由算法处理，除非另有说明。

注意，由于授权链无法通过授权而被拒绝的事件不应出现在此过程中，因为它们不应出现在状态中（算法仅使用在状态集中或状态集事件的授权链中的事件）。

> [!info] 合理性（RATIONALE）：
> 这样有助于确保不同的服务器对状态的视图更可能趋于一致，因为事件的拒绝状态可能不同。如果第三个服务器在某台服务器通过它加入房间时提供错误版本的状态，会导致这样的情况（可能是由于故障或恶意）。状态的一致性是一个令人期望的属性，因为它确保了房间中所有用户对房间状态的一致视图。如果不同服务器的状态视图产生分歧，可能会因为例如服务器对房间中谁的分歧，从而导致房间的分裂。
>
> 直观上，使用拒绝的事件似乎很危险，然而：
>
> 1. 服务器不能随意编造状态，因为它们仍然需要通过基于事件授权链的授权检查（例如，如果没有之前的权力等级，则无法给自己提升权力等级）。
> 2. 要让先前拒绝的事件通过授权，必须存在允许该事件的状态集。恶意服务器因此可以生成一个分叉，其中声称状态是该特定状态集，复制拒绝的事件指向该分叉，并发送该事件。复制的事件然后可以通过授权检查。忽视拒绝的事件因此不会消除任何潜在的攻击向量。

故意被排除用于迭代授权检查的拒绝授权事件，因为授权事件在迭代授权检查中不重新授权（尽管非授权事件会重新授权）。

#### 正式JSON[](https://spec.matrix.org/v1.11/rooms/v8/#canonical-json)

服务器必须严格执行[附录](https://spec.matrix.org/v1.11/appendices#canonical-json)中指定的JSON格式。这意味着在大多数端点上会出现400 `M_BAD_JSON`错误，或者在联邦中丢弃事件。例如，联邦API的`/send`端点会丢弃事件，而客户端服务器API的`/send/{eventType}`端点会返回`M_BAD_JSON`错误。

#### 签名密钥有效期[](https://spec.matrix.org/v1.11/rooms/v8/#signing-key-validity-period)

在验证事件签名时，服务器必须确保从密钥请求中获取的`valid_until_ts`属性至少与正在验证的事件的`origin_server_ts`一样大。缺少签名密钥副本的服务器必须尝试通过[GET /_matrix/key/v2/server](https://spec.matrix.org/v1.11/server-server-api#get_matrixkeyv2server)或[POST /_matrix/key/v2/query](https://spec.matrix.org/v1.11/server-server-api#post_matrixkeyv2query) API获取一个。当使用`/query`端点时，服务器必须设置`minimum_valid_until_ts`属性，以提示公证服务器在适当时尝试刷新密钥。

服务器在确定密钥是否有效时，必须使用`valid_until_ts`和未来7天中的较小者。这是为了避免攻击者发布一个有效时间较长但房主无法撤销的密钥的情况。

## 房间版本 9

此房间版本基于[版本8](https://spec.matrix.org/v1.11/rooms/v8)添加了在合并v8时无意中遗漏的额外删除规则。

### 客户端考虑事项[](https://spec.matrix.org/v1.11/rooms/v9/#client-considerations)

有关限制房间的具体详细信息，请参阅[房间版本8](https://spec.matrix.org/v1.11/rooms/v8)。

在本地实现删除算法的客户端应参考下面的[删除](https://spec.matrix.org/v1.11/rooms/v9/#redactions)部分以获取完整概述。

#### 删除[](https://spec.matrix.org/v1.11/rooms/v9/#redactions)

**[此版本新增]** [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)事件在被删除时现在保留`join_authorised_via_users_server`以及`content`中的其他键。

> [!info] 理由：
> 没有`join_authorised_via_users_server`属性，删除的加入事件在验证给定事件的授权链时可能会变得无效，从而创建一个分裂脑的场景，其中用户可以从一个服务器的角度发言，但大多数其他服务器将不断拒绝他们的事件。
> 
> 这可以通过重新加入房间来理论上解决，注意不要使用错误的事件作为`prev_events`，但建议使用v9房间而不是v8房间以完全避免这种情况。
> 
> [问题#3373](https://github.com/matrix-org/matrix-doc/issues/3373)有更多信息。

完整的删除算法如下。

收到删除事件后，服务器必须删除不在以下列表中的任何键：

- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `prev_state`
- `auth_events`
- `origin`
- `origin_server_ts`
- `membership`

内容对象也必须删除所有键，除非它是以下事件类型之一：

- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)允许键`membership`，`join_authorised_via_users_server`。
- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)允许键`creator`。
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)允许键`join_rule`，`allow`。
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)允许键`ban`，`events`，`events_default`，`kick`，`redact`，`state_default`，`users`，`users_default`。
- [`m.room.history_visibility`](https://spec.matrix.org/v1.11/client-server-api#mroomhistory_visibility)允许键`history_visibility`。

### 服务器实现组件[](https://spec.matrix.org/v1.11/rooms/v9/#server-implementation-components)

> [!warning] 警告：
> 本节中的信息严格适用于服务器实现者。使用客户端服务器API的应用程序通常不受此处包含的复杂性影响。上面关于客户端考虑的部分是客户端服务器API用例应参考的资源。

房间版本8添加了一个新的`restricted`加入规则，允许房间成员在没有邀请的情况下加入另一个房间。房间版本9基于v8，考虑了以下事项。

#### 删除[](https://spec.matrix.org/v1.11/rooms/v9/#redactions-1)

[见上文](https://spec.matrix.org/v1.11/rooms/v9/#redactions)。

### 从v8未更改[](https://spec.matrix.org/v1.11/rooms/v9/#unchanged-from-v8)

以下部分自v8以来未修改，但为完整性而包含。

#### 处理删除[](https://spec.matrix.org/v1.11/rooms/v9/#handling-redactions)

在房间版本1和2中，删除明确是[授权规则](https://spec.matrix.org/v1.11/rooms/v1/#authorization-rules)的一部分，位于规则11下。从房间版本3开始，这些条件不再存在，如[此版本的授权规则](https://spec.matrix.org/v1.11/rooms/v9/#authorization-rules)所示。

虽然删除始终被事件的授权规则接受，但在删除事件和删除影响的事件都已接收并可以验证之前，不应将其发送给客户端。如果两个事件都是有效的并且已被服务器看到，则服务器在满足以下条件之一时应用删除：

1. 删除事件的`sender`的权限级别大于或等于_redact level_。
2. 删除事件的`sender`的域与原始事件的`sender`的域匹配。

如果服务器会应用删除，则删除事件也会发送给客户端。否则，服务器只需等待一个有效的合作事件到达，然后可以重新检查上述条件。

#### 事件ID[](https://spec.matrix.org/v1.11/rooms/v9/#event-ids)

事件ID是事件的[参考哈希](https://spec.matrix.org/v1.11/server-server-api#calculating-the-reference-hash-for-an-event)，使用[不带填充的Base64](https://spec.matrix.org/v1.11/appendices#unpadded-base64)的变体进行编码，其中第62和63个字符分别用`-`和`_`替换，而不是使用`+`和`/`。这符合[RFC4648对URL安全base64的定义](https://tools.ietf.org/html/rfc4648#section-5)。

事件ID仍以`$`为前缀，可能看起来像`$Rqnc-F-dvnEYJTyHq_iKxU2bZ1CI92-kuZq3a5lr5Zg`。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v9/#event-format)

此版本房间中的事件具有以下结构：

##### `Persistent Data Unit`

---

房间版本4及以后的持久数据单元（事件）。

|Persistent Data Unit|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`auth_events`|`[string]`|**必需：**<br><br>允许此事件在房间中的授权事件的事件ID。<br><br>必须包含小于或等于10个事件。请注意，如果使用相关的授权事件选择规则，则永远不应遇到此限制。|
|`content`|`object`|**必需：** 事件的内容。|
|`depth`|`integer`|**必需：** `prev_events`的最大深度，加一。必须小于整数的最大值（2^63 - 1）。如果房间的深度已达到限制，则深度必须设置为限制。|
|`hashes`|[事件哈希](https://spec.matrix.org/v1.11/rooms/v9/#definition-persistent-data-unit_event-hash)|**必需：** PDU的内容哈希，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`origin_server_ts`|`integer`|**必需：** 创建此事件时原始家庭服务器上的时间戳，以毫秒为单位。|
|`prev_events`|`[string]`|**必需：**<br><br>创建此事件时家庭服务器知道的房间中最近事件的事件ID。<br><br>必须包含小于或等于20个事件。|
|`redacts`|`string`|对于删除事件，正在删除的事件的ID。|
|`room_id`|`string`|**必需：** 房间标识符。|
|`sender`|`string`|**必需：** 发送事件的用户ID。|
|`signatures`|`{string: {string: string}}`|**必需：** PDU的签名，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。|
|`state_key`|`string`|如果此键存在，则事件是状态事件，它将替换房间状态中具有相同`type`和`state_key`的先前事件。|
|`type`|`string`|**必需：** 事件类型|
|`unsigned`|[UnsignedData](https://spec.matrix.org/v1.11/rooms/v9/#definition-persistent-data-unit_unsigneddata)|由原始服务器添加但不受`signatures`覆盖的附加数据。|

|事件哈希|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`sha256`|`string`|**必需：** 哈希。|

|UnsignedData|
|---|---|---|
|名称|类型|描述|
|---|---|---|
|`age`|`integer`|自此消息发送以来经过的毫秒数。|

###### 示例

```json
{
  "auth_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "redacts": "$some-old_event",
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

##### 已弃用的事件内容模式[](https://spec.matrix.org/v1.11/rooms/v9/#deprecated-event-content-schemas)

发送到此版本房间的事件可以具有与其正常模式不同的格式。这些情况在此记录。

> [!warning] 警告：
> 此处描述的行为严格为向后兼容而保留。家庭服务器应采取合理的预防措施，以防止用户发送这些所谓的“格式错误”事件，并且绝不应将此处描述的行为作为默认行为。

###### `m.room.power_levels`事件接受字符串形式的值[](https://spec.matrix.org/v1.11/rooms/v9/#mroompower_levels-events-accept-values-as-strings)

为了与早期实现保持向后兼容，[`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)事件中的每个整数值属性可以编码为字符串而不是整数。这包括`events`、`notifications`和`users`属性中的嵌套值。例如，以下是此房间版本中有效的`m.room.power_levels`事件：

```json
{
  "content": {
    "ban": "50",
    "events": {
      "m.room.power_levels": "100"
    },
    "events_default": "0",
    "state_default": "50",
    "users": {
      "@example:localhost": "100"
    },
    "users_default": "0"
  },
  "origin_server_ts": 1432735824653,
  "room_id": "!jEsUZKDJdhlrceRyVU:example.org",
  "sender": "@example:example.org",
  "state_key": "",
  "type": "m.room.power_levels"
}
```

当值代表整数时，它们必须是以下格式：

- 单个十进制整数，没有浮点值或小数点，可选地带有任意数量的前导零（`"100"`，`"000100"`）；
- 可选地在整数前加上一个`-`或`+`字符（`"+100"`，`"-100"`）。
- 可选地带有任意数量的前导或尾随空格字符（`" 100 "`，`" 00100 "`，`" +100 "`，`" -100 "`）；

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v9/#authorization-rules)

事件必须由`sender`属性指定的服务器签名。

影响授权的状态事件类型有：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 当未明确提供时，权限级别从默认值推断。例如，提到`sender`的权限级别也可以指房间中用户的默认权限级别。

> [!info] 信息：
> `m.room.redaction`事件与任何其他事件一样受授权规则的约束。实际上，这意味着除非`m.room.power_levels`事件通过`events`或`events_default`属性为`m.room.redaction`事件设置权限级别要求，否则它们通常会被授权规则允许。特别是，_redact level_ **不**被授权规则考虑。
>
>发送删除事件的能力并不意味着删除本身应该执行。接收服务器必须执行额外的检查，如[处理删除](https://spec.matrix.org/v1.11/rooms/v9/#handling-redactions)部分所述。

规则如下：

1. 如果类型是`m.room.create`：
    1. 如果它有任何`prev_events`，拒绝。
    2. 如果`room_id`的域与`sender`的域不匹配，拒绝。
    3. 如果`content.room_version`存在且不是已识别的版本，拒绝。
    4. 如果`content`没有`creator`属性，拒绝。
    5. 否则，允许。
2. 考虑事件的`auth_events`：
    1. 如果给定`type`和`state_key`对有重复条目，拒绝。
    2. 如果有条目，其`type`和`state_key`与服务器规范中描述的[授权事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法指定的不匹配，拒绝。
    3. 如果有条目本身在[接收PDU时执行的检查](https://spec.matrix.org/v1.11/server-server-api/#checks-performed-on-receipt-of-a-pdu)下被拒绝，拒绝。
    4. 如果条目中没有`m.room.create`事件，拒绝。
3. 如果房间状态中的`m.room.create`事件的`content`属性`m.federate`设置为`false`，且事件的`sender`域与创建事件的`sender`域不匹配，拒绝。
4. 如果类型是`m.room.member`：
    1. 如果没有`state_key`属性，或`content`中没有`membership`属性，拒绝。
    2. 如果`content`有`join_authorised_via_users_server`属性：
        1. 如果事件未由密钥指定的用户ID的家庭服务器有效签名，拒绝。
    3. 如果`membership`是`join`：
        1. 如果唯一的先前事件是`m.room.create`且`state_key`是创建者，允许。
        2. 如果`sender`与`state_key`不匹配，拒绝。
        3. 如果`sender`被禁止，拒绝。
        4. 如果`join_rule`是`invite`或`knock`，则允许如果成员状态是`invite`或`join`。
        5. 如果`join_rule`是`restricted`：
            1. 如果成员状态是`join`或`invite`，允许。
            2. 如果`content`中的`join_authorised_via_users_server`键不是具有足够权限邀请其他用户的用户，拒绝。
            3. 否则，允许。
        6. 如果`join_rule`是`public`，允许。
        7. 否则，拒绝。
    4. 如果`membership`是`invite`：
        1. 如果`content`有`third_party_invite`属性：
            1. 如果_目标用户_被禁止，拒绝。
            2. 如果`content.third_party_invite`没有`signed`属性，拒绝。
            3. 如果`signed`没有`mxid`和`token`属性，拒绝。
            4. 如果`mxid`与`state_key`不匹配，拒绝。
            5. 如果当前房间状态中没有`state_key`匹配`token`的`m.room.third_party_invite`事件，拒绝。
            6. 如果`sender`与`m.room.third_party_invite`的`sender`不匹配，拒绝。
            7. 如果`signed`中的任何签名与`m.room.third_party_invite`事件中的任何公钥匹配，允许。公钥在`m.room.third_party_invite`的`content`中：
                1. `public_key`属性中的单个公钥。
                2. `public_keys`属性中的公钥列表。
            8. 否则，拒绝。
        2. 如果`sender`的当前成员状态不是`join`，拒绝。
        3. 如果_目标用户_的当前成员状态是`join`或`ban`，拒绝。
        4. 如果`sender`的权限级别大于或等于_邀请级别_，允许。
        5. 否则，拒绝。
    5. 如果`membership`是`leave`：
        1. 如果`sender`与`state_key`匹配，允许当且仅当该用户的当前成员状态是`invite`、`join`或`knock`。
        2. 如果`sender`的当前成员状态不是`join`，拒绝。
        3. 如果_目标用户_的当前成员状态是`ban`，且`sender`的权限级别小于_禁止级别_，拒绝。
        4. 如果`sender`的权限级别大于或等于_踢出级别_，且_目标用户_的权限级别小于`sender`的权限级别，允许。
        5. 否则，拒绝。
    6. 如果`membership`是`ban`：
        1. 如果`sender`的当前成员状态不是`join`，拒绝。
        2. 如果`sender`的权限级别大于或等于_禁止级别_，且_目标用户_的权限级别小于`sender`的权限级别，允许。
        3. 否则，拒绝。
    7. 如果`membership`是`knock`：
        1. 如果`join_rule`不是`knock`，拒绝。
        2. 如果`sender`与`state_key`不匹配，拒绝。
        3. 如果`sender`的当前成员状态不是`ban`、`invite`或`join`，允许。
        4. 否则，拒绝。
    8. 否则，成员状态未知。拒绝。
5. 如果`sender`的当前成员状态不是`join`，拒绝。
6. 如果类型是`m.room.third_party_invite`：
    1. 当且仅当`sender`的当前权限级别大于或等于_邀请级别_时允许。
7. 如果事件类型的_必需权限级别_大于`sender`的权限级别，拒绝。
8. 如果事件有一个以`@`开头且与`sender`不匹配的`state_key`，拒绝。
9. 如果类型是`m.room.power_levels`：
    1. 如果`content`中的`users`属性不是一个键为有效用户ID且值为整数（或表示整数的字符串）的对象，拒绝。
    2. 如果房间中没有先前的`m.room.power_levels`事件，允许。
    3. 对于`users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`、`invite`属性，检查它们是否被添加、更改或删除。对于每个发现的更改：
        1. 如果当前值高于`sender`的当前权限级别，拒绝。
        2. 如果新值高于`sender`的当前权限级别，拒绝。
    4. 对于在`events`或`notifications`属性中更改或删除的每个条目：
        1. 如果当前值大于`sender`的当前权限级别，拒绝。
    5. 对于在`events`或`notifications`属性中添加或更改的每个条目：
        1. 如果新值大于`sender`的当前权限级别，拒绝。
    6. 对于在`users`属性中更改或删除的每个条目，除了`sender`自己的条目：
        1. 如果当前值大于或等于`sender`的当前权限级别，拒绝。
    7. 对于在`users`属性中添加或更改的每个条目：
        1. 如果新值大于`sender`的当前权限级别，拒绝。
    8. 否则，允许。
10. 否则，允许。

> [!info] 信息：
> 这些规则的一些后果：
> 
> - 除非您是房间的成员，否则唯一允许的操作（除了初始创建/加入）是：加入公共房间；接受或拒绝房间邀请。
> - 要取消禁止某人，您必须具有大于或等于踢出和禁止级别的权限级别，并且大于目标用户的权限级别。

#### 状态解析[](https://spec.matrix.org/v1.11/rooms/v9/#state-resolution)

事件 E 之后的房间状态 S'(E) 根据事件 E 之前的房间状态 S(E) 来定义，并根据 E 是状态事件还是消息事件：

- 如果 E 是消息事件，则 S'(E) = S(E)。
- 如果 E 是状态事件，那么 S'(E) 是 S(E)，只是它对应于 E 的 `event_type` 和 `state_key` 的条目被 E 的 `event_id` 替换。

事件 E 之前的房间状态 S(E) 是事件 E 的 `prev_event` 集合 {E_1, E_2, …} 之后状态 {S'(E_1), S'(E_2), …} 的解析。下面的算法给出了状态集合的解析。

##### 定义[](https://spec.matrix.org/v1.11/rooms/v9/#definitions)

版本2房间的状态解析算法使用以下定义，给定房间状态集合 {S_1, S_2, …}：

**权限事件。** 权限事件是一个类型为 `m.room.power_levels` 或 `m.room.join_rules` 的状态事件，或者是 `membership` 为 `leave` 或 `ban` 且 `sender` 不匹配 `state_key` 的 `m.room.member` 状态事件。其背后的想法是，权限事件是可能会限制某人房间操作能力的事件。

**无冲突状态映射和冲突状态集合。** 状态映射 S_i 的键是形如 K = `(event_type, state_key)` 的字符串二元组。值 V 是状态事件。所有状态映射 S_i 中的键值对 (K, V) 可以分为两种集合。如果给定键 K 在每个 S_i 中都以相同的值 V 出现，那么配对 (K, V) 属于无冲突状态映射；否则，V 属于冲突状态集合。

注意，无冲突状态映射对于每个键 K 只有一个事件，而冲突状态集合可能包含具有相同键的多个事件。

**认证链。** 事件 E 的认证链是一个集合，包含所有 E 的认证事件，所有这些事件的认证事件，依此类推，递归地，追溯到房间的开始。换句话说，这些事件是通过遍历事件的 `auth_events` 连接所诱导的图而可达的事件。

**认证差异。** 认证差异是先计算每个状态 S_i 的完整认证链，即 S_i 中每个事件的认证链的并集，然后取出每个认证链中没有出现的每个事件。如果 C_i 是 S_i 的完整认证链，那么认证差异是 ∪C_i - ∩C_i。

**完整冲突集合。** 完整冲突集合是冲突状态集合和认证差异的并集。

**反向拓扑权限排序。** 事件集的反向拓扑权限排序是基于验证事件形成的 DAG 进行词典上最小的拓扑排序。反向拓扑权限排序的顺序是从最早的事件到最近的事件。比较两个拓扑排序以确定哪一个是词典上最小的，使用以下事件比较关系：对于事件 x 和 y，x < y 如果

1. x 的发送者的权限级别大于 y 的发送者的权限级别时，参照其各自的 `auth_event`s；或者
2. x 和 y 的发送者具有相同的权限级别，但 x 的 `origin_server_ts` 小于 y 的 `origin_server_ts`；或者
3. x 和 y 的发送者具有相同的权限级别且事件具有相同的 `origin_server_ts`，但 x 的 `event_id` 小于 y 的 `event_id`。

反向拓扑权限排序可以通过使用 Kahn 算法进行拓扑排序来找到，并且在每一步中，从所有候选顶点中选择最小的顶点，使用上述比较关系。

**主线排序。** 设 P = P_0 为一个 `m.room.power_levels` 事件。从 i = 0 开始，反复获取 P_i+1，即 P_i 的 `auth_events` 中的 `m.room.power_levels` 事件。递增 i 并重复，直到 P_i 的 `auth_events` 中没有 `m.room.power_levels` 事件。P_0 的主线是以这种方式获取的事件列表 [P_0, P_1, …, P_n]。

设 e = e_0 为另一个事件（可能是另一个 `m.room.power_levels` 事件）。我们可以计算类似的事件列表 [e_1, …, e_m]，其中 e_j+1 是 e_j 的 `auth_events` 中的 `m.room.power_levels` 事件，并且 e_m 的 `auth_events` 中没有 `m.room.power_levels` 事件。（注意，我们开始的事件 e_0 不包含在此列表中。也注意它可能是空的，因为 e 可能在其 `auth_events` 中根本没有引用 `m.room.power_levels` 事件。）

现在按如下方式比较这两个列表。

- 找出最小索引 j ≥ 1，e_j 属于 P 的主线。
- 如果存在这样的 j，则 e_j = P_i 对某个唯一的索引 i ≥ 0。否则，设 i = ∞，其中 ∞ 是大于任何整数的哨兵值。
- 在这两种情况下，e 的主线位置是 i。

根据从 P 计算的主线位置，基于 P 的一组事件的主线排序是从最小到最大的排序，其使用的以下事件比较关系：对于事件 x 和 y，x < y 如果

1. x 的主线位置大于 y 的主线位置（即 x 的认证链基于主线中早于 y 的事件）；或者
2. 事件的主线位置相同，但 x 的 `origin_server_ts` 小于 y 的 `origin_server_ts`；或者
3. 事件的主线位置相同且事件具有相同的 `origin_server_ts`，但 x 的 `event_id` 小于 y 的 `event_id`。

**迭代认证检查。** 迭代认证检查算法的输入是初始房间状态和一个已排序的状态事件列表，构造新的房间状态的过程是通过遍历事件列表，并将状态事件应用于房间状态，如果状态事件符合[认证规则](https://spec.matrix.org/v1.11/server-server-api#authorization-rules)。如果状态事件不符合认证规则，则忽略该事件。如果检查认证规则所需的 `(event_type, state_key)` 键在状态中不存在，则使用事件 `auth_events` 中的相应状态事件（如果认证事件没有被拒绝）。

##### 算法[](https://spec.matrix.org/v1.11/rooms/v9/#algorithm)

状态集合的解析通过以下步骤获得：

1. 选择完整冲突集合中所有权限事件的集合 X。对于每个此类权限事件 P，通过在完整冲突集合中添加 P 的认证链中的事件来扩展 X。使用反向拓扑权限排序将 X 排成一个列表。
2. 从无冲突状态映射开始，应用迭代认证检查算法到上一步事件列表，获得部分解析状态。
3. 取所有尚未在步骤1中选择的事件，按基于步骤2中获得的部分解析状态中的权限级别的主线排序排序。
4. 在部分解析状态和上一步事件列表上应用迭代认证检查算法。
5. 更新结果，替换任何事件为无冲突状态映射中具有相同键的事件（如果存在此类事件），以获得最终解析状态。

##### 被拒绝的事件[](https://spec.matrix.org/v1.11/rooms/v9/#rejected-events)

根据事件状态认证失败（而非基于其认证链）拒绝的事件，除非另有规定，否则算法按照通常处理。

注意，未授权链认证失败而被拒绝的事件不应出现在过程中，因为它们不应出现在状态中（算法仅使用在状态集合中或状态集合事件认证链中的事件）。

> [!info] 原因：
> 这有助于确保不同服务器的状态视图更可能收敛，因为事件的拒绝状态可能不同。如果第三方服务器在一个服务器通过它加入房间时给出不正确的状态版本，这种情况可能会发生（由于故障或恶意行为）。状态的收敛是一种理想的属性，因为它确保房间中的所有用户对房间的状态有一个（大部分）一致的观点。如果不同服务器对状态的观点分歧，可能导致房间分裂，例如，服务器对于谁在房间内的不同意见。
> 
> 从直觉上来看，使用被拒绝的事件感觉很危险，但是：
> 
> 1. 服务器不能随意编造状态，因为它们仍需通过基于事件认证链的认证检查（例如，它们不能授予自己权限级别，如果它们之前没有得到它们）。
> 2. 要通过认证一个先前被拒绝的事件，必须有一组允许该事件的状态。 因此，恶意服务器可以创建一个分支，声称状态是那一特定状态集的，并复制被拒绝的事件以指向该分支，并发送该事件。复制的事件随后将通过认证检查。因此，忽视被拒绝的事件不会消除任何潜在的攻击向量。

在迭代认证检查中，明确排除被拒绝的认证事件的使用，因为在迭代认证检查中，不会重新认证认证事件（尽管非认证事件会重新认证）。

#### 标准JSON[](https://spec.matrix.org/v1.11/rooms/v9/#canonical-json)

服务器必须严格执行[附录](https://spec.matrix.org/v1.11/appendices#canonical-json)中指定的JSON格式。这转化为大多数端点上返回 400 `M_BAD_JSON` 错误，或者在联邦中丢弃事件。例如，Federation API 的 `/send` 端点会丢弃事件，而 Client Server API 的 `/send/{eventType}` 端点会返回一个 `M_BAD_JSON` 错误。

#### 签名密钥有效期[](https://spec.matrix.org/v1.11/rooms/v9/#signing-key-validity-period)

在验证事件签名时，服务器必须执行的 `valid_until_ts` 属性，从密钥请求中获取的时间戳至少应比正在验证的事件的 `origin_server_ts` 大。缺少签名密钥副本的服务器必须尝试通过 [GET /_matrix/key/v2/server](https://spec.matrix.org/v1.11/server-server-api#get_matrixkeyv2server) 或 [POST /_matrix/key/v2/query](https://spec.matrix.org/v1.11/server-server-api#post_matrixkeyv2query) API 获取其副本。在使用 `/query` 端点时，服务器必须设置 `minimum_valid_until_ts` 属性，以促使公证服务器在适当的情况下尝试刷新密钥。

当确定密钥是否有效时，服务器必须使用 `valid_until_ts` 和未来7天之间的较小值。这是为了避免攻击者发布一个有效时间较长的密钥，而房屋服务器管理员无法撤销的情况。

## 房间版本10

此房间版本基于[版本9](https://spec.matrix.org/v1.11/rooms/v9)，要求权限级别值为整数，并引入一个新的 `knock_restricted` 加入规则，使准成员更容易加入此类房间。

### 客户端考虑事项[](https://spec.matrix.org/v1.11/rooms/v10/#client-considerations)

此房间版本添加了一个新的 `knock_restricted` 加加入规则，以允许房间的准成员通过 knock（在[房间版本7](https://spec.matrix.org/v1.11/rooms/v7) 中引入）或“加入限制”（在[房间版本8](https://spec.matrix.org/v1.11/rooms/v8) 中引入并在[房间版本9](https://spec.matrix.org/v1.11/rooms/v9) 中完善）加入。

客户端应根据此规则为该类房间渲染新的加入规则。例如：

```
此房间是：
[ ] 公共
[x] 私有

加入规则（当为公共时禁用）：
[x] 允许 `#space:example.org` 的成员加入
[x] 允许 knock
```

在本地实现去编辑算法的客户端应参考下方的[删除](https://spec.matrix.org/v1.11/rooms/v10/#redactions)部分以获得完整概述。

### 服务器实现组件[](https://spec.matrix.org/v1.11/rooms/v10/#server-implementation-components)

> [!warning] 警告：
> 此节包含的信息仅供服务器实施者使用。使用客户端-服务器API 的应用程序通常不受此处包含的复杂内容的影响。关于客户端考虑的内容适合客户端-服务器API的应用场景参考。

[房间版本7](https://spec.matrix.org/v1.11/rooms/v7) 添加了“knock”，[房间版本8](https://spec.matrix.org/v1.11/rooms/v8) 添加了“加入限制”（在[房间版本9](https://spec.matrix.org/v1.11/rooms/v9) 中精化）——两者都为潜在成员提供了加入的途径，但不能同时使用两种机制。此房间版本添加了一种新的 `knock_restricted` 加入规则，混合这两种行为，允许用户如果符合 `restricted` 加入规则条件或 `knock` 加入规则条件之一就能够加入。

此房间版本还要求权限级别事件中的值为整数而不是字符串表示，不同于其他房间版本。

房间版本10基于房间版本9，考虑如下。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v10/#event-format)

此房间版本的事件格式未更改。详情请见[下方](https://spec.matrix.org/v1.11/rooms/v10/#event-format-1)关于当前事件格式的说明。

##### 弃用的事件内容架构[](https://spec.matrix.org/v1.11/rooms/v10/#deprecated-event-content-schemas)

虽然此房间版本未具体更改事件格式，但一些不再支持的弃用行为已被严格禁止。

###### `m.room.power_levels`事件中的值必须为整数[](https://spec.matrix.org/v1.11/rooms/v10/#values-in-mroompower_levels-events-must-be-integers)

在其他房间版本，例如[v9](https://spec.matrix.org/v1.11/rooms/v9/#mroompower_levels-events-accept-values-as-strings)，为了向后兼容，权限级别可以用字符串表示。

此房间版本移除了这种向后兼容性——在此房间版本中，权限级别绝对不能以字符串表示。权限级别未正确构造的将根据以下授权规则遭到拒绝。

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v10/#authorization-rules)

事件必须由 `sender` 属性所指示的服务器签名。

影响授默认权限级别为用户使用时推断的基本权限级别。授权级别影响如下事件类型：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 如果用户没有明确提供默认的权限级别设备，则推断用户的权限级别。例如，提到 `sender` 的权限级别也可能指房间用户的默认权限级别。

> [!info] 信息：
> `m.room.redaction` 事件受到与任何其他事件相同的认证规则的约束。实际上，这意味着它们在通常情况下将被认证规则允许，除非 `m.room.power_levels` 事件通过 `events` 或 `events_default` 属性为 `m.room.redaction` 事件设置了权限级别要求。特别是，不考虑校订级别。
> 
> 发送校订事件的能力并不意味着校订本身应被执行。接收服务器必须执行额外的检查，如 [Handling redactions](https://spec.matrix.org/v1.11/rooms/v10/#handling-redactions) 部分中所述。

规则如下：

1. 如果类型是 `m.room.create`：
    1. 如果有任何 `prev_events`，拒绝。
    2. 如果 `room_id` 的域与 `sender` 的域不匹配，拒绝。
    3. 如果 `content.room_version` 存在且不是认可的版本，拒绝。
    4. 如果 `content` 中没有 `creator` 属性，拒绝。
    5. 否则，允许。
2. 考虑事件的 `auth_events`：
    1. 如果给定类型和状态键对有重复条目，拒绝。
    2. 如果有条目的类型和状态键与服务器规范中描述的[认证事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法指定的不匹配，拒绝。
    3. 如果有条目本身因[在收到PDU时执行的检查](https://spec.matrix.org/v1.11/server-server-api/#checks-performed-on-receipt-of-a-pdu)而被拒绝，拒绝。
    4. 如果条目中没有 `m.room.create` 事件，拒绝。
3. 如果房间状态中的 `m.room.create` 事件的 `content` 属性有 `m.federate` 设置为 `false`，且事件的 `sender` 域与创建事件的 `sender` 域不匹配，拒绝。
4. 如果类型是 `m.room.member`：
    1. 如果没有 `state_key` 属性，或者 `content` 中没有 `membership` 属性，拒绝。
    2. 如果 `content` 中有 `join_authorised_via_users_server` 键：
        1. 如果事件没有有效地由 `key` 表示的用户的家庭服务器签名，拒绝。
    3. 如果 `membership` 是 `join`：
        1. 如果唯一的先前事件是 `m.room.create` 且 `state_key` 是创建者，则允许。
        2. 如果 `sender` 不匹配 `state_key`，拒绝。
        3. 如果 `sender` 被禁止，拒绝。
        4. 如果 `join_rule` 是 `invite` 或 `knock`，则如果会员状态是 `invite` 或 `join`，允许。
        5. **[本版本更改]** 如果 `join_rule` 是 `restricted` 或 `knock_restricted`：
            1. 如果会员状态是 `join` 或 `invite`，则允许。
            2. 如果 `content` 中 `join_authorised_via_users_server` 键不是有权限邀请其他用户的用户，拒绝。
            3. 否则，允许。
        6. 如果 `join_rule` 是 `public`，允许。
        7. 否则，拒绝。
    4. 如果 `membership` 是 `invite`：
        1. 如果 `content` 中有 `third_party_invite` 属性：
            1. 如果目标用户被禁止，拒绝。
            2. 如果 `content.third_party_invite` 中没有 `signed` 属性，拒绝。
            3. 如果 `signed` 没有 `mxid` 和 `token` 属性，拒绝。
            4. 如果 `mxid` 不匹配 `state_key`，拒绝。
            5. 如果当前房间状态中没有`state_key`匹配 `token` 的 `m.room第三方邀请`事件，拒绝。
            6. 如果 `sender` 不匹配 `m.room第三方邀请` 的 `sender`，拒绝。
            7. 如果 `signed` 中的任何签名匹配 `m.room第三方邀请` 事件中的任何公钥，允许。公钥位于 `m.room第三方邀请` 的 `content` 中：
                1. `public_key` 属性中的单个公钥。
                2. `public_keys` 属性中的公钥列表。
            8. 否则，拒绝。
        2. 如果 `sender` 当前的会员状态不是 `join`，拒绝。
        3. 如果目标用户的当前会员状态是 `join` 或 `ban`，拒绝。
        4. 如果 `sender` 的权限级别大于或等于 `invite level`，允许。
        5. 否则，拒绝。
    5. 如果 `membership` 是 `leave`：
        1. 如果 `sender` 与 `state_key` 匹配，仅当该用户当前的会员状态是 `invite`、`join` 或 `knock` 时才允许。
        2. 如果 `sender` 当前的会员状态不是 `join`，拒绝。
        3. 如果目标用户当前的会员状态是 `ban`，并且 `sender` 的权限级别低于 `ban level`，拒绝。
        4. 如果 `sender` 的权限级别大于或等于 `kick level` 并且目标用户的权限级别低于 `sender` 的权限级别，允许。
        5. 否则，拒绝。
    6. 如果 `membership` 是 `ban`：
        1. 如果 `sender` 当前的会员状态不是 `join`，拒绝。
        2. 如果 `sender` 的权限级别大于或等于 `ban level` 并且目标用户的权限级别低于 `sender` 的权限级别，允许。
        3. 否则，拒绝。
    7. 如果 `membership` 是 `knock`：
        1. **[本版本更改]** 如果 `join_rule` 不是 `knock` 或 `knock_restricted`，拒绝。
        2. 如果 `sender` 不匹配 `state_key`，拒绝。
        3. 如果 `sender` 当前的会员状态不是 `ban`、`invite` 或 `join`，允许。
        4. 否则，拒绝。
    8. 否则，会员状态未知。拒绝。
5. 如果 `sender` 当前的会员状态不是 `join`，拒绝。
6. 如果类型是 `m.room第三方邀请`：
    1. 仅当 `sender` 当前的权限级别大于或等于 `invite级别` 时允许。
7. 如果事件类型的 `required power level` 大于 `sender` 的权限级别，拒绝。
8. 如果事件的 `state_key` 以 `@` 开头且不匹配 `sender`，拒绝。
9. 如果类型是 `m.room.power_levels`：
    1. **[新版中]** 如果 `content` 中的 `users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick` 或 `invite` 属性不为空且不是整数，拒绝。
    2. **[新版中]** 如果 `content` 中的 `events` 或 `notifications` 属性存在且不是具有整数值的对象，拒绝。
    3. 如果 `content` 中的 `users` 属性不是一个具有有效用户 ID 作为键且值为整数的对象，拒绝。
    4. 如果房间中没有先前的 `m.room.power_levels` 事件，允许。
    5. 对属性 `users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`、`invite` 进行检查，看它们是否已添加、更改或删除。对于每一个找到的更改：
        1. 如果当前值大于 `sender` 当前的权限级别，拒绝。
        2. 如果新值大于 `sender` 当前的权限级别，拒绝。
    6. 对于 `events` 或 `notifications` 属性中正在更改或删除的每个条目：
        1. 如果当前值大于 `sender` 当前的权限级别，拒绝。
    7. 对于 `events` 或 `notifications` 属性中正在添加或更改的每个条目：
        1. 如果新值大于 `sender` 当前的权限级别，拒绝。
    8. 对于 `users` 属性中除 `sender` 自己条目外的每个正在更改或删除的条目：
        1. 如果当前值大于或等于 `sender` 的当前权限级别，拒绝。
    9. 对于 `users` 属性中正在添加或更改的每个条目：
        1. 如果新值大于 `sender` 当前的权限级别，拒绝。
    10. 否则，允许。
10. 否则，允许。

事件ID仍然带有`$`前缀，可能会显得像`$Rqnc-F-dvnEYJTyHq_iKxU2bZ1CI92-kuZq3a5lr5Zg`。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v10/#event-format-1)

此版本房间内的事件结构如下：

##### `持久数据单元`

---

版本4及更高版本房间中的持久数据单元（事件）。

| 持久数据单元 |      |      |
| ------------ | ---- | ---- |
| 名称         | 类型 | 说明 |
| ----------- | --- | --- |
| `auth_events` | `[string]` | **必需：**<br><br>允许此事件在房间中存在的授权事件ID。<br><br>最多包含10个事件。注意，如果使用相关授权事件选择规则，永远不会遇到此限制。 |
| `content` | `object` | **必需：** 事件的内容。 |
| `depth` | `integer` | **必需：** `prev_events`的最大深度加一。必须小于整数的最大值（2^63 - 1）。如果房间的深度已经达到了限制，则深度必须设置为该限制。 |
| `hashes` | [事件哈希](https://spec.matrix.org/v1.11/rooms/v10/#definition-persistent-data-unit_event-hash) | **必需：** 事件的内容哈希，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。 |
| `origin_server_ts` | `integer` | **必需：** 创建此事件时在来源主服务器上的时间戳，以毫秒为单位。 |
| `prev_events` | `[string]` | **必需：**<br><br>此事件创建时主服务器已知的房间中最近事件的事件ID。<br><br>最多包含20个事件。 |
| `redacts` | `string` | 对于删除事件，被删除事件的ID。 |
| `room_id` | `string` | **必需：** 房间标识符。 |
| `sender` | `string` | **必需：** 发送事件的用户ID。 |
| `signatures` | `{string: {string: string}}` | **必需：** 事件的签名，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。 |
| `state_key` | `string` | 如果存在此键，该事件是一个状态事件，它将在房间状态中替换具有相同`type`和`state_key`的先前事件。 |
| `type` | `string` | **必需：** 事件类型 |
| `unsigned` | [未签名数据](https://spec.matrix.org/v1.11/rooms/v10/#definition-persistent-data-unit_unsigneddata) | 来源服务器添加的额外数据，但不包含在`signatures`中。 |

| 事件哈希 |      |      |
| ------- | ---- | ---- |
| 名称     | 类型 | 说明 |
| `sha256` | `string` | **必需：** 哈希值。 |

| 未签名数据 |      |      |
| ---------- | ---- | ---- |
| 名称        | 类型 | 说明 |
| `age`       | `integer` | 自此消息发送以来经过的毫秒数。 |

###### 示例

```json
{
  "auth_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "redacts": "$some-old_event",
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

#### 状态解析[](https://spec.matrix.org/v1.11/rooms/v10/#state-resolution)

事件_E_之后的房间状态_S′(E)_ 是基于事件_E_之前的房间状态_S(E)_定义的，且取决于_E_是否为状态事件或消息事件：

- 如果_E_是消息事件，则_S′(E)_ = _S(E)_。
- 如果_E_是状态事件，则_S′(E)_为_S(E)_，但其与_E_的`event_type`和`state_key`相对应的条目被_E_的`event_id`替代。

事件_E_之前的房间状态_S(E)_是事件_E_的`prev_event`s{_E_1, _E_2, ...}之后状态集{_S′(E_1)_, _S′(E_2)_, …}的解析。状态集的解析在下列算法中给出。

##### 定义[](https://spec.matrix.org/v1.11/rooms/v10/#definitions)

版本2房间的状态解析算法使用以下定义，给定房间状态集{_S_1, _S_2, …}：

**权限事件。** 权限事件是类型为`m.room.power_levels`、`m.room.join_rules`的状态事件，或为`m.room.member`类型并且`membership`为`leave`或`ban`且`sender`不匹配`state_key`的状态事件。其背后的想法是权限事件可能会移除某人在房间中执行某些操作的能力。

**不冲突状态映射和冲突状态集合。** 状态映射_Si_的键是形式为_K_的字符串二元组`(event_type, state_key)`。值_V_是状态事件。所有状态映射_Si_中的键值对(_K_, _V_)可分为两个集合。这种方法的作用是，如果给定键_K_在每个_Si_中都有相同值_V_，则对(_K_, _V_)属于不冲突状态映射。否则，_V_属于冲突状态集合。

注意不冲突状态映射中每个键_K_仅有一个事件，而冲突状态集合可能包含具有相同键的多个事件。

**授权链。** 事件_E_的授权链是一个集合，包含_E_的所有授权事件，它们的所有授权事件，依此类推，递归回滚到房间的开始。换句话说，这些事件是通过沿着事件的`auth_events`链接形成的图形遍历得到的。

**授权差异。** 授权差异通过首先计算每个状态_S_i_的完整授权链来计算，即_S_i_中每个事件的授权链的并集，然后提取未出现在每个授权链中的事件。如果_C_i_是_S_i_的完整授权链，则授权差异是 ∪ _C_i_ − ∩ _C_i_。

**完整冲突集合。** 完整冲突集合是冲突状态集合与授权差异的并集。

**反向拓扑权限排序。** 事件集的反向拓扑权限排序是基于授权事件形成的DAG的按字典顺序排列的最小拓扑排序。反向拓扑权限排序是从最早的事件到最新的事件。比较两个拓扑排序以决定哪个是按字典顺序最小的，使用以下事件的比较关系：对于事件_x_和_y_，_x_ < _y_ 如果

1. _x_的发送者权限级别比_y_的发送者高，根据各自的`auth_event`查看；或者
2. 发送者的权限级别相同，但_x_的`origin_server_ts`小于_y_的`origin_server_ts`；或者
3. 发送者的权限级别相同且事件具有相同的`origin_server_ts`，但_x_的`event_id`小于_y_的`event_id`。

通过使用Kahn算法进行拓扑排序，在每一步中排序事件，并在所有候选顶点中选择最小顶点可以找到反向拓扑权限排序。

**主线排序。** 设_P_ = _P_0为一个`m.room.power_levels`事件。从_i_ = 0开始，重复获取_P_i+1，该事件为_Pi_的`auth_events`中的`m.room.power_levels`事件。递增_i_ 并重复，直到_Pi_在其`auth_events`中没有`m.room.power_levels`事件。 _P_0的主线是按这种方式获取的事件列表[_P_0, _P_1, …, _Pn_]。

另一个事件_e_ = _e0_可以计算一个类似的事件列表[_e_1, …, _em_]，其中_e_j+1为_ej_的`auth_events`中的`m.room.power_levels`事件，且_em_在其`auth_events`中没有`m.room.power_levels`事件。（注意我们开始的事件_e0_未包含在此列表中。也注意可能为空，因为_e_可能在其`auth_events`中根本不引用`m.room.power_levels`事件。）

现在比较这两个列表如下。

- 找到最小索引_j_ ≥ 1，使得_ej_属于_P_的主线。
- 如果存在这样的_j_，那么_ej_ = _Pi_ 个对于某唯一起始索引_i_ ≥ 0。否则设_i_ = ∞，其中 ∞ 是大于任何整数的标记值。
- 在这两种情况下，_e_的主线位置是_i_。

给定基于_P_计算的主线位置，一组事件的_P_的主线排序是使用以下事件的比较关系从小到大的排序：对于事件_x_和_y_，_x < _y_ 如果

1. _x_的主线位置大于_y_的主线位置（即_x_的授权链基于主线中比_y_更早的事件）；或者
2. 事件的主线位置相同，_x_的`origin_server_ts`小于_y_的`origin_server_ts`；或者
3. 事件的主线位置相同，且事件具有相同的`origin_server_ts`，_x_的`event_id`小于_y_的`event_id`。

**迭代授权检查。** 迭代授权检查算法接受一个初始房间状态和一个已排序的状态事件列表作为输入，通过迭代该事件列表并在状态事件被授权规则允许时将状态事件应用于房间状态来构建新的房间状态。如果状态事件未被授权规则允许，则忽略该事件。如果一个用于检查授权规则的`(event_type, state_key)`键在状态中不存在，则使用事件的`auth_events`中的适当状态事件，如果授权事件未被拒绝。

##### 算法[](https://spec.matrix.org/v1.11/rooms/v10/#algorithm)

状态集的解析通过以下步骤得到：

1. 选择完整冲突集合中出现的所有权限事件的集合_X_。对于每个这样的权限事件_P_，通过添加也属于完整冲突集合的的_P_的授权链中的事件来扩展_X_。使用反向拓扑权限排序将$X$排成列表。
2. 从不冲突状态映射开始，应用迭代授权检查算法，处理先前步骤中的事件列表以获得部分解析的状态。
3. 对于步骤1中未选择的所有剩余事件，按基于步骤2中获得的部分解析状态的权限级别进行主线排序。
4. 在部分解析状态和步骤中的事件列表上应用迭代授权检查算法。
5. 更新结果，替换任何事件为不冲突状态映射中的具有相同键的事件（如果存在此类事件），以获得最终的解析状态。

##### 被拒绝的事件[](https://spec.matrix.org/v1.11/rooms/v10/#rejected-events)

由于根据事件状态（而不是根据它们的授权链）失败授权而被拒绝的事件，由算法按一般情况处理，除非另有说明。

请注意，由于未通过他们的授权链授权失败而被拒绝的事件不能出现在过程中，因为它们不应出现在状态中（算法仅使用那些出现在状态集内或作为状态集内事件的授权链的事件）。

> [!info] 理由：
> 这有助于确保不同服务器的状态视图更有可能收敛，因为一个事件的拒绝状态可能不同。这可能发生如果一个第三方服务器提供不正确的状态版本给一个服务器在通过它加入房间时（无论是由于失误或恶意）。状态的收敛是一个期望的属性，因为它保证所有房间内的用户具有一个（大多数）一致的状态视图。如果不同服务器的状态视图分歧可能导致房间的分叉，由于例如服务器对谁在房间的不同看法。
> 
> 直观上，使用被拒绝事件感觉很危险，然而：
> 
> 1. 服务器不能随意伪造状态，因为他们仍然需要通过基于事件的授权链的授权检查（例如如果他们之前没有权限，他们不能授予自己权限级别）。
> 2. 要让之前拒绝的事件通过授权，必须要有一个允许该事件的状态设置。因此，一个恶意服务器可以生成一个分叉，宣称状态是那个特定的状态集，然后将被拒绝的事件复制到指向那个分叉并发送该事件。复制的事件将通过授权检查。忽略被拒绝事件因此不会消除任何潜在攻击载体。

为了进行迭代授权检查，被拒绝授权事件故意从使用中排除，因为授权事件不会在迭代授权检查期间重新授权（尽管非授权事件被重新授权）。

#### 正式JSON[](https://spec.matrix.org/v1.11/rooms/v10/#canonical-json)

服务器必须严格执行附录指定的JSON格式。对此，大多数端点将响应400 `M_BAD_JSON`错误，或者在联盟中丢弃事件。例如，联邦API的`/send`端点将丢弃事件，而客户端-服务器API的`/send/{eventType}`端点将返回一个`M_BAD_JSON`错误。

#### 签名键的有效期[](https://spec.matrix.org/v1.11/rooms/v10/#signing-key-validity-period)

在验证事件签名中，服务器必须强制执行`valid_until_ts`属性在键请求中的最小值要大于等于正在验证事件的`origin_server_ts`。没有签名键副本的服务器必须尝试通过[GET /_matrix/key/v2/server](https://spec.matrix.org/v1.11/server-server-api#get_matrixkeyv2server)或[POST /_matrix/key/v2/query](https://spec.matrix.org/v1.11/server-server-api#post_matrixkeyv2query) API获取一个。当使用`/query`端点时，服务器必须设置`minimum_valid_until_ts`属性以促使公证服务器尝试在适当情况下刷新键。

服务器必须使用`valid_until_ts`和7天未来中的较小者确定一个键是否有效。这是为了避免攻击者发布一个有效期较长的键且没有办法被主服务器所有者吊销的情况。

## 房间版本11

这个房间版本构建在[版本10](https://spec.matrix.org/v1.11/rooms/v10)基础上，同时明确了删除规则。

### 客户端注意事项[](https://spec.matrix.org/v1.11/rooms/v11/#client-considerations)

#### 删除[](https://spec.matrix.org/v1.11/rooms/v11/#redactions)

**[此版本新功能]** 顶层`origin`、`membership`和`prev_state`属性不再受到删除保护。[`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)事件现在保留整个`content`属性。[`m.room.redaction`](https://spec.matrix.org/v1.11/client-server-api#mroomredaction)事件在`content`下保留`redacts`属性。[`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)事件在`content`下保留`invite`属性。

完整的删除算法如下。

收到删除事件后，服务器必须剥去不在下列列表中的任何键：

- `event_id`
- `type`
- `room_id`
- `sender`
- `state_key`
- `content`
- `hashes`
- `signatures`
- `depth`
- `prev_events`
- `auth_events`
- `origin_server_ts`

内容对象也必须剥去所有键，除非它是以下事件类型之一：

- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember) 允许键 `membership`，`join_authorised_via_users_server`。此外，它允许`third_party_invite`键中的`signed`键。
- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate) 允许所有键。
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules) 允许键 `join_rule`，`allow`。
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels) 允许键 `ban`，`events`，`events_default`，`invite`，`kick`，`redact`，`state_default`，`users`，`users_default`。
- [`m.room.history_visibility`](https://spec.matrix.org/v1.11/client-server-api#mroomhistory_visibility) 允许键 `history_visibility`。
- [`m.room.redaction`](https://spec.matrix.org/v1.11/client-server-api#mroomredaction) 允许键 `redacts`。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v11/#event-format)

客户端不应再依赖[`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)事件中`content`的`creator`属性。在所有房间版本中，客户端可以依赖`sender`来确定房间的创建者。

[`m.room.redaction`](https://spec.matrix.org/v1.11/client-server-api#mroomredaction)事件的格式已被修改。客户端应在事件`content`下寻找`redacts`键，而非顶层事件属性。

[`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)事件的`third_party_invite`键不再被删除，但在删除后将仅包含`signed`键。

### 服务器实现组件[](https://spec.matrix.org/v1.11/rooms/v11/#server-implementation-components)

> [!warning] 警告：
> 此部分的信息严格为服务器实现者准备。使用客户端-服务器API的应用程序通常不受此处包含的复杂性的影响。上面有关客户端注意事项的部分是客户端-服务器API用例应参考的资源。

此房间版本更新了删除算法，并修改了服务器应如何创建`m.room.create`和`m.room.redaction`事件。

房间版本11基于房间版本10，有以下注意事项。

#### 删除[](https://spec.matrix.org/v1.11/rooms/v11/#redactions-1)

[见上文](https://spec.matrix.org/v1.11/rooms/v11/#redactions)。

#### 事件格式[](https://spec.matrix.org/v1.11/rooms/v11/#event-format-1)

核心事件格式与[房间版本10](https://spec.matrix.org/v1.11/rooms/v10#event-format)相同。然而，此房间版本改变了一些事件类型的属性。

此版本房间中的事件结构如下：

##### `持久数据单元`

---

版本11及更高版本房间中的持久数据单元（事件）。

| 持久数据单元 |      |      |
| ------------ | ---- | ---- |
| 名称         | 类型 | 说明 |
|--------|------|-------|
| `auth_events` | `[string]` | **必需：**<br><br>允许此事件在房间中存在的授权事件ID。<br><br>最多包含10个事件。注意，如果使用相关授权事件选择规则，永远不会遇到此限制。 |
| `content` | `object` | **必需：** 事件的内容。 |
| `depth` | `integer` | **必需：** `prev_events`的最大深度加一。必须小于整数的最大值（2^63 - 1）。如果房间的深度已经达到了限制，则深度必须设置为该限制。 |
| `hashes` | [事件哈希](https://spec.matrix.org/v1.11/rooms/v11/#definition-persistent-data-unit_event-hash) | **必需：** 事件的内容哈希，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。 |
| `origin_server_ts` | `integer` | **必需：** 创建此事件时在来源主服务器上的时间戳，以毫秒为单位。 |
| `prev_events` | `[string]` | **必需：**<br><br>此事件创建时主服务器已知的房间中最近事件的事件ID。<br><br>最多包含20个事件。 |
| `room_id` | `string` | **必需：** 房间标识符。 |
| `sender` | `string` | **必需：** 发送事件的用户ID。 |
| `signatures` | `{string: {string: string}}` | **必需：** 事件的签名，遵循[签名事件](https://spec.matrix.org/v1.11/server-server-api/#signing-events)中指定的算法。 |
| `state_key` | `string` | 如果存在此键，该事件是一个状态事件，它将在房间状态中替换具有相同`type`和`state_key`的先前事件。 |
| `type` | `string` | **必需：** 事件类型 |
| `unsigned` | [未签名数据](https://spec.matrix.org/v1.11/rooms/v11/#definition-persistent-data-unit_unsigneddata) | 来源服务器添加的额外数据，但不包含在`signatures`中。 |

| 事件哈希 |      |      |
| ------- | ---- | ---- |
| 名称     | 类型 | 说明 |
| `sha256` | `string` | **必需：** 哈希值。 |

| 未签名数据 |      |      |
| ---------- | ---- | ---- |
| 名称        | 类型 | 说明 |
| `age`       | `integer` | 自此消息发送以来经过的毫秒数。 |

###### 示例

```json
{
  "auth_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "content": {
    "key": "value"
  },
  "depth": 12,
  "hashes": {
    "sha256": "thishashcoversallfieldsincasethisisredacted"
  },
  "origin": "example.com",
  "origin_server_ts": 1404838188000,
  "prev_events": [
    "$urlsafe_base64_encoded_eventid",
    "$a-different-event-id"
  ],
  "room_id": "!UcYsUzyxTGDxLBEvLy:example.org",
  "sender": "@alice:example.com",
  "signatures": {
    "example.com": {
      "ed25519:key_version:": "these86bytesofbase64signaturecoveressentialfieldsincludinghashessocancheckredactedpdus"
    }
  },
  "type": "m.room.message",
  "unsigned": {
    "age": 4612
  }
}
```

##### 移除`m.room.create`事件的`creator`属性[](https://spec.matrix.org/v1.11/rooms/v11/#remove-the-creator-property-of-mroomcreate-events)

`m.room.create`事件的`content`不再具有`creator`属性，以前该属性始终等同于事件的`sender`。

##### 将`m.room.redaction`事件的`redacts`属性移动到`content`属性下[](https://spec.matrix.org/v1.11/rooms/v11/#moving-the-redacts-property-of-mroomredaction-events-to-a-content-property)

`m.room.redaction`事件的`redacts`属性从顶层事件属性移动到事件`content`属性下。

为与旧版客户端的向后兼容，服务器在通过客户端-服务器API提供此类事件时，应在`m.room.redaction`事件的顶层添加`redacts`属性。

为提高与新版客户端的兼容性，服务器在通过客户端-服务器API提供较旧房间版本的此类事件时，应在`m.room.redaction`事件的`content`下添加`redacts`属性。

#### 授权规则[](https://spec.matrix.org/v1.11/rooms/v11/#authorization-rules)

事件必须由`sender`属性指定的服务器签署。

影响授权的状态事件类型是：

- [`m.room.create`](https://spec.matrix.org/v1.11/client-server-api#mroomcreate)
- [`m.room.member`](https://spec.matrix.org/v1.11/client-server-api#mroommember)
- [`m.room.join_rules`](https://spec.matrix.org/v1.11/client-server-api#mroomjoin_rules)
- [`m.room.power_levels`](https://spec.matrix.org/v1.11/client-server-api#mroompower_levels)
- [`m.room.third_party_invite`](https://spec.matrix.org/v1.11/client-server-api#mroomthird_party_invite)

> [!info] 信息：
> 如果未明确提供，权限级别将从默认推断。例如，提及`sender`的权限级别也可能是房间中用户的默认权限级别。

> [!info] 信息：
> `m.room.redaction`事件与其他事件一样受授权规则的约束。实际上，这意味着它们通常会被授权规则允许，除非`m.room.power_levels`事件通过`events`或`events_default`属性设置了对`m.room.redaction`事件的权限要求。具体来说，授权规则**不**会考虑删除级别。
> 
> 能够发送删除事件并不意味着删除本身应该执行。接收服务器必须执行额外的检查，如[处理删除](https://spec.matrix.org/v1.11/rooms/v11/#handling-redactions)章节中描述的。

规则如下：

1. **[此版本变更]** 如果类型是`m.room.create`：
    1. 如果有任何`prev_events`，拒绝。
    2. 如果`room_id`的域与`sender`的域不匹配，拒绝。
    3. 如果存在`content.room_version`且不是公认版本，拒绝。
    4. 否则，允许。
2. 鉴于事件的`auth_events`：
    1. 如果存在给定`type`和`state_key`对的重复条目，拒绝。
    2. 如果存在不匹配服务器规范中描述的[授权事件选择](https://spec.matrix.org/v1.11/server-server-api#auth-events-selection)算法的条目，拒绝。
    3. 如果存在由于[接收PDU时执行的检查](https://spec.matrix.org/v1.11/server-server-api/#checks-performed-on-receipt-of-a-pdu)而被拒绝的条目，拒绝。
    4. 如果条目中没有`m.room.create`事件，拒绝。
3. 如果房间状态中的`m.room.create`事件的`content`属性具有`m.federate`设置为`false`，且事件的`sender`域与创建事件的`sender`域不匹配，拒绝。
4. 如果类型是`m.room.member`：
    1. 如果没有`state_key`属性，或没有`content`中的`membership`属性，拒绝。
    2. 如果`content`具有`join_authorised_via_users_server`键：
        1. 如果事件未由该键指定的用户ID的主服务器有效签名，拒绝。
    3. 如果`membership`是`join`：
        1. **[此版本变更]** 如果唯一先前事件是`m.room.create`且`state_key`是发送者，允许。
        2. 如果`sender`不匹配`state_key`，拒绝。
        3. 如果`sender`被禁，拒绝。
        4. 如果`join_rule`是`invite`或`knock`，则允许，如果成员状态是`invite`或`join`。
        5. 如果`join_rule`是`restricted`或`knock_restricted`：
            1. 如果成员状态是`join`或`invite`，允许。
            2. 如果`content`中的`join_authorised_via_users_server`键不是具有足够权限的用户，拒绝。
            3. 否则，允许。
        6. 如果`join_rule`是`public`，允许。
        7. 否则，拒绝。
    4. 如果`membership`是`invite`：
        1. 如果`content`具有`third_party_invite`属性：
            1. 如果目标用户被禁，拒绝。
            2. 如果`content.third_party_invite`没有`signed`属性，拒绝。
            3. 如果`signed`没有`mxid`和`token`属性，拒绝。
            4. 如果`mxid`与`state_key`不匹配，拒绝。
            5. 如果当前房间状态中没有`state_key`匹配`token`的`m.room.third_party_invite`事件，拒绝。
            6. 如果`sender`不匹配`m.room.third_party_invite`的发送者，拒绝。
            7. 如果`signed`中的任何签名匹配在`m.room.third_party_invite`事件内的任何公钥，允许。这些公钥在`m.room.third_party_invite`的`content`中：
                1. 在`public_key`属性中的一个公钥。
                2. 在`public_keys`属性中的公钥列表。
            8. 否则，拒绝。
        2. 如果`sender`的当前成员状态不是`join`，拒绝。
        3. 如果目标用户的当前成员状态是`join`或`ban`，拒绝。
        4. 如果`sender`的权限级别大于或等于邀请级别，允许。
        5. 否则，拒绝。
    5. 如果`membership`是`leave`：
        1. 如果`sender`匹配`state_key`，且仅当该用户的当前成员状态是`invite`、`join`或`knock`时，允许。
        2. 如果`sender`的当前成员状态不是`join`，拒绝。
        3. 如果目标用户的当前成员状态是`ban`，且`sender`的权限级别小于禁级别，拒绝。
        4. 如果`sender`的权限级别大于或等于踢级别，且目标用户的权限级别小于`sender`的权限级别，允许。
        5. 否则，拒绝。
    6. 如果`membership`是`ban`：
        1. 如果`sender`的当前成员状态不是`join`，拒绝。
        2. 如果`sender`的权限级别大于或等于禁级别，且目标用户的权限级别小于`sender`的权限级别，允许。
        3. 否则，拒绝。
    7. 如果`membership`是`knock`：
        1. 如果`join_rule`不是`knock`或`knock_restricted`，拒绝。
        2. 如果`sender`不匹配`state_key`，拒绝。
        3. 如果`sender`的当前成员状态不是`ban`、`invite`或`join`，允许。
        4. 否则，拒绝。
    8. 否则，身份未明确。拒绝。
5. 如果`sender`的当前成员状态不是`join`，拒绝。
6. 如果类型是`m.room.third_party_invite`：
    1. 仅当`sender`的当前权限级别大于等于邀请级别时允许。
7. 如果事件类型的所需权限级别大于`sender`的权限级别，拒绝。
8. 如果事件具有以`@`开头的`state_key`且不匹配`sender`，拒绝。
9. 如果类型是`m.room.power_levels`：
    1. 如果`content`中的属性`users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`或`invite`存在且不是整数，拒绝。
    2. 如果`content`中的属性`events`或`notifications`存在且其值不是表示整数的对象，拒绝。
    3. 如果`content`中的`users`属性不是具有有效用户ID键和整数值的对象，拒绝。
    4. 如果房间中没有先前的 `m.room.power_levels` 事件，允许。
    5. 对于属性 `users_default`、`events_default`、`state_default`、`ban`、`redact`、`kick`、`invite` 检查是否新增、更改或删除。对于每个发现的更改：
        1. 如果当前值高于 `sender` 的当前权限级别，拒绝。
        2. 如果新值高于 `sender` 的当前权限级别，拒绝。
    6. 对于 `events` 或 `notifications` 属性中被更改或移除的每个条目：
        1. 如果当前值大于 `sender` 的当前权限级别，拒绝。
    7. 对于 `events` 或 `notifications` 属性中新增或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权限级别，拒绝。
    8. 对于 `users` 属性中被更改或移除的每个条目，除了 `sender` 自己的条目：
        1. 如果当前值大于或等于 `sender` 的当前权限级别，拒绝。
    9. 对于 `users` 属性中新增或更改的每个条目：
        1. 如果新值大于 `sender` 的当前权限级别，拒绝。
    10. 否则，允许。

> [!info] 信息：
> 这些规则的一些结果：
> 
> - 除非您是房间的成员，否则唯一允许的操作（除了初始创建/加入）是：加入一个公共房间；接受或拒绝房间邀请。
> - 要取消禁止某人，您必须拥有大于或等于踢除和禁止级别的权限，并且大于目标用户的权限级别。

### 从 v10 未更改的部分[](https://spec.matrix.org/v1.11/rooms/v11/#unchanged-from-v10)

以下部分自 v10 起未修改，包含在内以便完整性。

#### 处理撤销操作[](https://spec.matrix.org/v1.11/rooms/v11/#handling-redactions)

在房间版本1和2中，撤销操作在第11条规则中明确成为[授权规则](https://spec.matrix.org/v1.11/rooms/v1/#authorization-rules)的一部分。从房间版本3开始，这些条件不再存在于[此版本的授权规则](https://spec.matrix.org/v1.11/rooms/v11/#authorization-rules)中表示。

虽然授权规则总是接受事件的撤销操作，但在撤销事件和撤销影响的事件都被接收并验证之前，不应将其发送给客户端。如果两个事件都有效并且服务器已看到，则服务器会在满足以下条件之一时应用撤销：

1. 撤销事件的 `sender` 的权限级别大于或等于 _redact level_。
2. 撤销事件的 `sender` 的域与原始事件的 `sender` 的域匹配。

如果服务器会应用撤销操作，则撤销事件也会发送给客户端。否则，服务器会简单地等待一个有效的伙伴事件到达以便再次检查上述条件。

#### 事件ID[](https://spec.matrix.org/v1.11/rooms/v11/#event-ids)

事件 ID 是使用[未填充的 Base64](https://spec.matrix.org/v1.11/appendices#unpadded-base64)中替换为 `-` 和 `_` 的第62和63个字符对事件的[引用哈希](https://spec.matrix.org/v1.11/server-server-api#calculating-the-reference-hash-for-an-event)。这与[RFC4648的URL安全base64定义](https://tools.ietf.org/html/rfc4648#section-5)匹配。

事件 ID 仍以`$`为前缀，可能显示为`$Rqnc-F-dvnEYJTyHq_iKxU2bZ1CI92-kuZq3a5lr5Zg`。

#### 状态解析[](https://spec.matrix.org/v1.11/rooms/v11/#state-resolution)

事件后的房间状态 _S′(E)_ 是基于事件前的房间状态 _S(E)_ 定义的，并取决于事件是状态事件还是消息事件：

- 如果 E 是消息事件，则 S′(E) = S(E)。
- 如果 E 是状态事件，则 S′(E) 是 S(E)，只是与 E 的 `event_type` 和 `state_key` 相应的条目由 E 的 `event_id` 替换。

事件 E 之前的房间状态 S(E) 是事件 E 的 `prev_event`s {_E_1, E_2, …} 之后状态 {_S′(E_1), S′(E_2), …} 的解决方案。状态集合的解决方案按以下算法给出。

##### 定义[](https://spec.matrix.org/v1.11/rooms/v11/#definitions)

版本2房间的状态解析算法使用以下定义，给出房间状态集合 {_S_1, S_2, …}：

**权限事件。** 权限事件是类型为 `m.room.power_levels` 或 `m.room.join_rules` 的状态事件，或类型为 `m.room.member` 且 `membership` 为 `leave` 或 `ban` 且 `sender` 不匹配 `state_key` 的状态事件。此背后的想法是权限事件可能移除某人在房间中执行某些操作的能力。

**无冲突状态映射和冲突状态集合。** 状态映射 Si 的键是形式为 K = `(event_type, state_key)` 的字符串的2元组。值 V 是状态事件。所有状态映射 Si 中的键值对 (K, V) 可以分为两个集合。如果给定键 K 存在于每个 Si 中且在每个状态映射中的值 V 相同，则对 (K, V) 属于无冲突状态映射。否则，V 属于冲突状态集合。

注意，无冲突状态映射对每个键 K 只有一个事件，而冲突状态集合可能包含具有相同键的多个事件。

**授权链。** 事件 E 的授权链是一个集合，包含所有发起事件的授权事件，它们的授权事件，以此类推，递归地一直追溯到房间的开头。换句话说，这些事件是通过事件的 `auth_events` 链接的图行走可以到达的。

**授权差异。** 授权差异通过首先计算每个状态 Si 的完整授权链（即对 Si 中每个事件的授权链求并集），然后取每个不出现在每个授权链中的事件。对于 Ci 是 Si 的完整授权链，则授权差异是 ∪ Ci − ∩ Ci。

**完整冲突集合。** 完整冲突集合是冲突状态集合与授权差异的并集。

**反向拓扑权限排序。** 一组事件的反向拓扑权限排序是基于授权事件形成的 DAG 的字典序最小拓扑排序。反向拓扑权限排序从最早的事件到最新。用于确定哪个是字典序最小的拓扑排序的事件比较关系为：对于事件 x 和 y，x < y 如果

1. x 的发送者比 y 的发送者有更高的权限级别，查看它们各自的 `auth_event`；
2. 发送者有相同的权限级别，但 x 的 `origin_server_ts` 小于 y 的 `origin_server_ts`；
3. 发送者有相同的权限级别且事件具有相同的 `origin_server_ts`，但 x 的 `event_id` 小于 y 的 `event_id`。

反向拓扑权限排序可以通过使用 Kahn 的拓扑排序算法对事件进行排序，并在每一步中在所有候选顶点中选择最小的顶点来找到。

**主线排序。** 令 P = P_0 为 `m.room.power_levels` 事件。从 i = 0 开始，反复获取 Pi+1，即 Pi 中 `auth_events` 的 `m.room.power_levels` 事件。递增 i 并重复，直到 Pi 在其 `auth_events` 中没有 `m.room.power_levels` 事件。P_0 的主线是以这种方式获取的事件列表 [P_0, P_1, …, Pn]。

令 e = e0 为另一个事件（可能是另一 `m.room.power_levels` 事件）。我们可以计算类似的事件列表 [e_1, …, em]，其中 ej+1 是 ej 中 `auth_events` 的 `m.room.power_levels` 事件，且 em 在其 `auth_events` 中没有 `m.room.power_levels` 事件。（注意我们开始时的事件 e0 不在此列表中。还要注意它可能为空，因为 e 可能根本不在其 `auth_events` 中引用 `m.room.power_levels` 事件。）

现在比较这两个列表。

- 找出最小索引 j ≥ 1，使得 ej 属于 P 的主线。
- 如果存在这样的 j，则 ej = Pi 对于某个唯一索引 i ≥ 0。否则设 i = ∞，其中 ∞ 是大于任何整数的哨兵值。
- 在两种情况下，事件 e 的主线位置为 i。

给定从 P 计算的主线位置，基于 P 的事件集合的主线排序是从小到大的排序，使用以下事件比较关系：对于事件 x 和 y，x < y 如果

1. x 的主线位置大于 y 的主线位置（即 x 的授权链基于主线中早于 y 的事件）；或者
2. 事件的主线位置相同，但 x 的 `origin_server_ts` 小于 y 的 `origin_server_ts`；或者
3. 事件的主线位置相同且事件具有相同的 `origin_server_ts`，但 x 的 `event_id` 小于 y 的 `event_id`。

**迭代授权检查。** 迭代授权检查算法以初始房间状态和已排序的状态事件列表作为输入，并通过遍历事件列表在满足[授权规则](https://spec.matrix.org/v1.11/server-server-api#authorization-rules)的条件时将状态事件应用于房间状态以构建新房间状态。如果状态事件不满足授权规则，则事件被忽略。如果检查授权规则时需要的 `(event_type, state_key)` 键在状态中不存在，则使用事件的 `auth_events` 中的适当状态事件（如果授权事件没有被拒绝）。

##### 算法[](https://spec.matrix.org/v1.11/rooms/v11/#algorithm)

通过以下步骤获得状态集合的解析：

1. 选择出现在完整冲突集合中的所有权限事件 X。对于每个此类权限事件 P，通过将 P 的授权链中也属于完整冲突集合的事件添加到 X 来扩大 X。使用反向拓扑权限排序对 X 进行排序。
2. 使用从无冲突状态映射开始的迭代授权检查算法对上一步事件列表进行部分解析状态。
3. 将步骤 1 中未选择的所有剩余事件按基于步骤 2 中部分解析状态的权限级别的主线排序。
4. 使用部分解析状态和上一步事件列表再次应用迭代授权检查算法。
5. 通过替换任何事件为无冲突状态映射中的同一键的事件（如果存在这样的事件）来更新结果，以获得最终解析状态。

##### 拒绝事件[](https://spec.matrix.org/v1.11/rooms/v11/#rejected-events)

由于无法通过基于事件状态的授权而被拒绝的事件，除非另有说明，通常由该算法处理。

注意，由于授权链无效而被拒绝的事件不应出现在过程中，因为它们不应出现在状态中（算法仅使用状态集合或状态集合中的事件的授权链中出现的事件）。

> [!info] 理由：
> 这有助于确保不同服务器的状态视图更可能收敛，因为事件的拒绝状态可能不同。发生这种情况是如果第三服务器在服务器通过它加入房间时给出了错误的状态（由于故障或恶意）。状态收敛是一个可取的属性，因为它确保房间中的所有用户对房间状态有一个（大致）一致的视图。如果不同服务器上的状态视图分歧，可能导致房间的分裂，例如服务器对谁在房间中的意见不一致。
> 
> 直观地使用拒绝事件感觉危险，但：
> 
> 1. 服务器不能随意编造状态，因为它们仍需要通过基于事件授权链的授权检查（例如，如果之前没有权限，它们不能为自己赋予权限级别）。
> 2. 要通过授权一个先前被拒绝的事件，必须有一组允许该事件的状态。因此，恶意服务器可以创建一个分叉，声称该状态是特定状态集合，复制被拒绝的事件指向该分叉，然后发送事件。复制的事件将通过授权检查。因此，忽略拒绝事件不会消除任何潜在的攻击向量。

被拒绝的授权事件故意从迭代授权检查中排除，因为授权事件在迭代中不会重新进行授权检查（尽管非授权事件会进行）。

#### 规范 JSON[](https://spec.matrix.org/v1.11/rooms/v11/#canonical-json)

服务器必须严格遵守[附录](https://spec.matrix.org/v1.11/appendices#canonical-json)中规定的JSON格式。这会导致大多数端点返回400 `M_BAD_JSON`错误，或者在联邦上丢弃事件。例如，联邦API的 `/send` 端点会丢弃事件，而客户端服务器API的 `/send/{eventType}` 端点会返回 `M_BAD_JSON` 错误。

#### 签名密钥有效期[](https://spec.matrix.org/v1.11/rooms/v11/#signing-key-validity-period)

在验证事件签名时，服务器必须强制执行密钥请求中的 `valid_until_ts` 属性至少和被验证事件的 `origin_server_ts` 一样大。缺少签名密钥副本的服务器必须尝试通过[GET /_matrix/key/v2/server](https://spec.matrix.org/v1.11/server-server-api#get_matrixkeyv2server) 或 [POST /_matrix/key/v2/query](https://spec.matrix.org/v1.11/server-server-api#post_matrixkeyv2query) API 获得一个。当使用 `/query` 端点时，服务器必须设置 `minimum_valid_until_ts` 属性以提示公证服务器在适当情况下尝试刷新密钥。

服务器在确定密钥是否有效时，必须使用 `valid_until_ts` 和未来7天中的较小者。这是为了避免攻击者发布一个有效期长时间且无其他方法让家服务器所有者撤销的密钥的情况出现。
```