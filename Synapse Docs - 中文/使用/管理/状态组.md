### 状态组如何工作？

作为一般规则，我鼓励那些想了解数据库模式最深奥秘的人访问 #synapse-dev:matrix.org 并提问。

然而，经常出现的一个问题是“状态组”是如何工作的，以及为什么 `state_groups_state` 表会变得如此之大，所以这里尝试回答这个问题。

我们需要能够相对快速地计算出房间在其历史上任何时间点的状态。换句话说，我们需要知道房间在每个事件时的状态。这可以通过以下方式完成：

将状态相同的连续事件分组到一个 `state_group` 中；映射记录在 `event_to_state_groups` 中。（从技术上讲，由于状态事件通常会改变房间的状态，我们记录的是给定事件 ID 之后的房间状态：也就是说，简化来说，状态组中的第一个事件通常是状态事件，而同一状态组中的其他事件通常是非状态事件。）

`state_groups` 记录了每个状态组的房间 ID，以及该组中第一个事件的 ID。（我不确定这个事件 ID 在实践中是否经常使用。）

现在，如果我们为每个 `state_group` 存储所有房间状态，那将是大量的数据。相反，对于每个状态组，我们通常存储该组与其他状态组之间的状态差异，并且仅在每 100 次状态变化左右记录完整状态。

因此，大多数状态组在 `state_group_edges` 中有一个条目（别问我为什么它不是 `state_groups` 中的一列），该条目记录房间中之前的状态组，而 `state_groups_state` 记录自该之前状态组以来的状态差异。

一个完整的状态组仅记录房间中每个状态点的事件 ID。

#### 已知状态组的错误

我们可能会因为各种原因创建比需要的更多的状态组：请查看 https://github.com/matrix-org/synapse/issues/3364 获取更多详情。

#### 压缩工具

在 https://github.com/matrix-org/rust-synapse-compress-state 有一个工具，可以按房间逐个压缩 `state_groups_state` （本质上，它减少了“完整”状态组的数量）。这可以显著减少所使用的存储空间。