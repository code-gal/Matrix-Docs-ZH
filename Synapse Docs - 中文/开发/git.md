一些关于我们如何使用 git 的说明
============================

保持提交历史清晰
-----------------------------------

在理想的情况下，我们的 git 提交历史将是一个线性进程，每个提交都包含一个单一的更改，建立在之前的基础上。这里，通过一个任意的例子，展示了 `git log --graph b2dba0607` 的顶部：

<img src="img/git/clean.png" alt="clean git graph" width="500px">

注意提交评论清楚地解释了正在更改的内容和原因。还要注意*没有*合并提交，以及没有像（挑选几个罪魁祸首）[“pep8”](https://github.com/element-hq/synapse/commit/84691da6c)、[“fix broken test”](https://github.com/element-hq/synapse/commit/474810d9d)、[“oops”](https://github.com/element-hq/synapse/commit/c9d72e457)、[“typo”](https://github.com/element-hq/synapse/commit/836358823) 或 [“Who's the president?”](https://github.com/element-hq/synapse/commit/707374d5d) 这样的提交。

保持提交历史清晰有很多原因：

 * 有时，在更改落地后，发现需要撤销它，或者将其回移到发布分支。当更改包含在单个提交中时，这些操作要*容易得多*。

 * 同样，回答类似“/publicRooms 的修复是否在发布分支上？”这样的问题要容易得多，如果该更改由单个提交组成。

 * 同样：“在过去一周中，此分支上发生了什么变化？”在没有到处都是合并和“pep8”提交的情况下要清晰得多。

 * 有时我们需要找出错误是何时引入的，或者某些行为何时发生了变化。这样做的一种方法是使用 `git bisect`：在已知良好点和已知不良点之间选择一个任意提交，看看代码的行为如何。然而，如果你选择的提交是某人史诗分支的中间部分，他们在其中打破了世界然后又重新组合起来，这种策略就会失败。

一个反对的观点是，有时查看 PR 在审查周期中如何演变是有用的。这是真的，但通过 GitHub UI（或通过鲜为人知的 [refs/pull namespace](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally)）总是可以获得该信息。

当然，实际上，事情比这更复杂。我们有发布分支以及 `develop` 和 `master`，我们故意在它们之间合并更改。错误经常会溜过来，必须在以后修复。这都很好：这不是一个必须遵守的铁律，而是一个理想的目标。

合并、压缩、变基：wtf？
-------------------------------

好的，这就是我们想要实现的目标。我们如何实现它？

简而言之，当你准备合并一个拉取请求时，你*可能*想要“压缩并合并”：
![squash and merge](Synapse%20Docs%20-%20中文/开发/img/git/squash.png))。

（这适用于你合并自己的 PR，或其他贡献者的 PR。）

“压缩并合并”<sup id="a1">[1](#f1)</sup> 将 PR 中的所有更改捆绑成一个提交。GitHub 给你机会在确认之前编辑提交消息，通常你应该这样做，因为默认值将是无用的（再次：`* woops typo` 不是保留在历史记录中的有用内容）。

这种方法的主要问题在于，当你有一系列构建在彼此之上的拉取请求时：一旦你压缩合并第一个 PR，你将在所有其他 PR 中遇到一堆冲突。通常，最好避免这种情况，首先尽量不要同时有多个相关的 PR。然而，有时这是不可能的，进行常规合并是较小的恶。

另一种情况下，常规合并更有意义的是一个 PR，其中你故意创建了一系列每个都在其自身权利上有意义的提交。例如：[一个逐渐将重构操作传播到代码库的 PR](https://github.com/matrix-org/synapse/pull/6837)，或[一个是几个其他 PR 的高潮的 PR](https://github.com/matrix-org/synapse/pull/5987)。在这种情况下，找出特定更改/错误何时引入可能非常有用。

最终：**这不是一个硬性规则**。如果不确定，问问自己“我将要合并的每个提交是否在其自身权利上有意义”，但请记住，我们只是尽力在“保持提交历史清晰”与其他因素之间取得平衡。

Git 分支模型
-------------------

关于 git 分支模型已经写了[很多](https://nvie.com/posts/a-successful-git-branching-model/)
[文字](http://scottchacon.com/2011/08/31/github-flow.html)
[（很多）](https://www.endoflineblog.com/gitflow-considered-harmful)。我倾向于认为整个事情被过度炒作了。从根本上说，这并不那么复杂。以下是我们的做法。

让我们从一张图片开始：
![branching model](Synapse%20Docs%20-%20中文/开发/img/git/branches.jpg))

看起来很复杂，但实际上并不是。基本规则是：*任何人*都可以在*任何*时间从*任何*更稳定的分支合并到*任何*不太稳定的分支<sup id="a2">[2](#f2)</sup>。（其背后的原则是，如果更改足够好，可以放入更稳定的分支，那么它也足够好，可以放入不太稳定的分支。）

同时，从不太稳定的分支合并（或压缩，如上所述）到更稳定的分支是一个有意的动作，你希望将更改或一组更改发布给（某个子集的）世界：例如，这发生在 PR 落地时，或作为我们发布过程的一部分。

那么，什么算作更稳定或不太稳定的分支呢？稍加思考就会发现，我们的活动分支按从更稳定到不太稳定的顺序排列如下：

 * `master`（跟踪我们上次发布）。
 * `release-vX.Y`（我们在其中准备下一个发布的分支）<sup id="a3">[3](#f3)</sup>。
 * 目标是发布的 PR 分支。
 * `develop`（我们的“主线”分支，包含我们的前沿）。
 * 常规 PR 分支。

推论是：如果你有一个需要同时落地在 `release-vX.Y` 和 `develop` 的错误修复，那么你应该基于 `release-vX.Y` 创建 PR，让它合并到那里，然后从 `release-vX.Y` 合并到 `develop`。（如果修复落地在 `develop`，我们后来需要在发布分支中，我们当然可以 cherry-pick 它，但首先在发布分支中落地有助于减少恼人的冲突。）

---

<b id="f1">[1]</b>：“压缩并合并”是 GitHub 对此操作的术语。鉴于没有涉及合并，我不认为这是最直观的名称。[↑](#a1)

<b id="f2">[2]</b>：好吧，任何有提交权限的人。[↑](#a2)

<b id="f3">[3]</b>：非常，非常偶尔（我认为这在 Synapse 的历史上发生过一次），我们同时有两个发布在进行中。显然，`release-v1.2` 比 `release-v1.3` 更稳定。[↑](#a3)