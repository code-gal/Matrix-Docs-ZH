在部分加入期间发送消息时，我们假设我们的部分状态是准确的并正常进行。为了使这有任何成功的希望，我们的部分状态必须包含授权规则[指定的（类型，状态键）对](https://spec.matrix.org/v1.3/rooms/v10/#authorization-rules)：

- `m.room.create`
- `m.room.join_rules`
- `m.room.power_levels`
- `m.room.third_party_invite`
- `m.room.member`

在我们收到的部分加入响应中，前四个应该在状态 `J` 之前存在；只有成员事件被省略。为了让我们认为用户已加入，我们必须拥有他们的成员事件。这意味着唯一可能的省略是目标在邀请、踢出或禁止中的成员身份。

最糟糕的可能性是，我们本地邀请了一个根据完整状态被禁止的人，因为我们在当前的部分状态中缺少他们的禁止。其余的联邦——至少是那些完全加入的——应该正确执行[成员资格转换约束](https://spec.matrix.org/v1.3/client-server-api/#room-membership)。因此，任何错误的邀请都应该被完全加入的主服务器忽略，并通过部分加入主服务器的重新同步来解决。

更一般地说，我们在这里担心两个问题：

- 我们可能会创建一个在我们的部分状态下有效的事件，后来才发现根据完整状态实际上是无效的。
- 或者：我们可能会拒绝创建一个在我们的部分状态下无效的事件，即使在完整状态下它是完全有效的。

然而，我们预计在实践中这些问题不太可能发生，因为

- 我们相信房间有合理的权限级别，例如，在坏角色被降级之前，他们的权限级别很高。
- 我们相信驻留服务器为我们提供最新的权限级别、加入规则等。
- 房间中的状态变化相对不频繁，重新同步周期相对较快。

###### 通过联邦发送事件

**TODO：** 需要详细说明。

通常：在联邦事务中发送到房间中的所有主服务器。
我们只知道某些主服务器曾经在房间中。怎么办。
将其发送到首次加入的服务器列表。
**TODO** 如果我们有完整状态，我们在这里该怎么办？
如果前一个事件是由我们创建的，我们可以冒险将其发送到错误的主服务器。（动机：内容的隐私问题。对于公共房间或加密房间来说，这不是一个大问题。但不想以这种方式在其他主服务器的事件中发送敏感数据。）

假设我们在重新同步后发现我们不应该将我们的一个事件（不是前一个事件）发送到目标主服务器。我们无能为力。
如果我们没有发送给他们一个事件但应该发送呢？
例如，如果有人在您之后不久从一个新的主服务器加入？我们不会与他们交谈。
可以想象在重新同步后发送“错过的”事件，但……很难弄清楚如果他们加入/离开时应该看到什么。
相反，只需发送最新事件（如果他们在重新同步后仍在房间中）并让他们回填。（？）
- 目前不这样做。
- 如果收到我们消息的任何人向我们错过的主服务器发送消息，他们可以回填我们的消息
- 缺口：不常用且需要很长时间重新同步的房间。

##### 部分加入后的加入

**注意。** 尚未实施。

<details>

**TODO：** 需要详细说明。与Matthieu联系。解释为什么/发送加入（Rich对我们不直接在本地创建感到惊讶。答案：为了避免在重新同步后被拒绝的加入。）

我们不能确定我们创建的任何加入都会被接受。
例如，加入的用户可能已被禁止；加入规则可能已更改，而我们没有意识到……部分状态错误的某种方式。
相反，再次进行部分创建-加入/发送-加入握手以确认加入有效。
- 可能会得到一堆重复的状态事件和授权事件……但部分加入的重点是这些应该很小。许多已经持久化=好。
- 如果第二次发送加入响应包含不同的驻留主服务器列表怎么办？可以忽略它。
  - 甚至可以有一个特殊标志，表示“只给我一个加入”，即不必给我状态或房间中的服务器。绝对想要授权链。
- SQ：关于设备列表，忽略它更安全！！！
- 如果第二次加入时的状态与我们拥有的不一致怎么办？忽略它？

</details>

##### 部分加入后的离开（以及踢出和禁止）

**注意。** 尚未实施。

<details>

当您完全加入一个房间时，要让 `U` 离开房间，他们的主服务器需要

- 为 `U` 创建一个新的离开事件，该事件将被其他主服务器接受，并且
- 将该事件 `U` 发送到联邦中的主服务器。

何时接受离开事件？请参阅[v10授权规则](https://spec.matrix.org/v1.5/rooms/v10/#authorization-rules)：

> 4. 如果类型是 m.room.member: [...]
     >
     >    5. 如果成员资格是离开：
             >
             >       1. 如果发送者与 state_key 匹配，则仅当且仅当该用户的当前成员状态是邀请、加入或敲门时才允许。
>       2. [...]

我认为这意味着（格式良好的！）自我离开完全由4.5.1管理。这意味着如果我们正确计算状态，表明 `U` 被邀请、加入或敲门，并将其包含在离开的授权事件中，我们的事件将通过传入事件的检查4和5。

> 4. 根据事件的授权事件通过授权规则，否则
     >    它被拒绝。
> 5. 根据事件之前的状态通过授权规则，否则
     >    它被拒绝。

唯一可能未通过检查6的方式是接收服务器的当前房间状态表明 `U` 被禁止、已离开或没有成员事件。但这没关系：接收服务器已经认为 `U` 不在房间中。

> 6. 根据房间的当前状态通过授权规则，
     >    否则它是“软失败”。

对于第二点（发布离开事件），我们能做的最好的事情是发布到我们知道当前在房间中的所有主服务器。如果他们错过了该事件，他们可能会向我们发送我们不关心的房间流量。这是“完全”加入后离开的一个问题；我们不寻求通过部分加入来解决这个问题。

（话虽如此：/发送响应中没有机器可读的内容。我不认为我们可以从未能/发送事件到该房间中推断出“目的地已离开房间”？）

###### 我们仍然可以在部分加入期间这样做吗？

我们可以创建离开事件，并可以选择包含在我们的授权事件中的内容，因此我们可以确保我们通过传入事件的检查4。对于检查5，我们可能对事件之前的状态有不正确的看法。
我们可能错误地认为离开是有效的唯一方式是

- 离开之前的部分状态有 `U` 加入、邀请或敲门，但
- 离开之前的完整状态有 `U` 被禁止、已离开或不存在，

在这种情况下，离开不会使事情变得更糟：其他主服务器已经认为我们不在房间中，并将在看到离开后继续这样认为。

剩下的障碍是：我们可以安全地广播离开事件吗？我们可能会错过服务器或错误地认为服务器在房间中。或者目标服务器可能离线并错过包含我们离开事件的事务。当他们看到一个 `prev_events` 从我们的离开中继承的事件时，这应该会自我修复。

我们考虑的另一个选项是使用联邦 `/send_leave` 请求一个完全加入的服务器代表我们发送事件。但这增加了复杂性而没有太多好处。此外，正如Rich所说，

> 发送离开目前是相当尽力而为的

所以这可能已经足够好了。

###### 最后一次离开后的清理

**TODO**：需要进行哪些清理？是否只是为了节省未使用的工作？

</details>