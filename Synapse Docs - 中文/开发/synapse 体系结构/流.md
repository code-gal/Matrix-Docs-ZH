#### 流

Synapse有一个“流”的概念，这在[`id_generators.py`](https://github.com/element-hq/synapse/blob/develop/synapse/storage/util/id_generators.py)中有大致描述。
一般来说，流是一系列通知，表示Synapse的数据库中发生了变化，应用程序可能需要响应。
例如：

- 事件流报告Synapse创建的新事件（PDU），或Synapse从另一个主服务器接受的新事件。
- 账户数据流报告用户[账户数据](https://spec.matrix.org/v1.7/client-server-api/#client-config)的更改。
- 设备流报告设备有新的[设备消息](https://spec.matrix.org/v1.7/client-server-api/#send-to-device-messaging)。

请参阅[`synapse.replication.tcp.streams`](https://github.com/element-hq/synapse/blob/develop/synapse/replication/tcp/streams/__init__.py)以获取完整的流列表。

了解流机制对于处理任何需要响应更改的Synapse部分非常有帮助，尤其是当这些更改由不同的工作者完成时。
为此，让我们正式描述流，改述[`AbstractStreamIdGenerator`](https://github.com/element-hq/synapse/blob/a719b703d9bd0dade2565ddcad0e2f3a7a9d4c37/synapse/storage/util/id_generators.py#L96)的文档字符串。

##### 定义

流是一个追加的日志 `T1, T2, ..., Tn, ...`，随着时间的推移而增长。
只有“写入者”可以向流中添加事实，并且可能有多个写入者。

每个事实都有一个ID，称为“流ID”。
读者应仅按升序处理流ID的事实。

大致来说，每个流都有一个数据库表作为后盾。
它应该有一个 `stream_id`（或类似的）bigint列来保存流ID，以及描述事实所需的其他列。
通常，事实用其后备表中的单行表示。[2]
在一个流中，没有两个事实可以有相同的stream_id。

> _旁注_。关于流的后备表的一些附加说明。
>
> 1. Rich希望[放弃后备表](https://github.com/matrix-org/synapse/issues/13456)。
> 2. 后备表可能有其他用途。
     >    例如，事件表为事件流提供支持，并在处理新事件时读取。
     >    但旧行会一直从表中读取，每当Synapse需要查找事件的某些事实时。
> 3. Rich怀疑有时流由多个表支持，因此流本身是这些表的并集。

流写入者可以“保留”一个流ID，然后稍后将其标记为已完成。
流写入者需要跟踪每个流事实的完成情况。
在理想情况下，完成意味着事实已被写入流表。
但不幸的情况（例如，由于错误导致的事务回滚）也算作完成。
一旦完成，使用该流ID写入的行将固定，并且不会插入具有该ID的新行。

##### 当前流ID

对于任何给定的流读者（包括写入者本身），我们可以定义每个写入者的当前流ID：

> 写入者W的当前流ID是最大的流ID，
> 使得W添加的所有事务都已完成。

同样，有一个“线性”概念的当前流ID：

> “线性”当前流ID是最大的流ID，
> 使得所有具有相同或更小ID的事实（由任何写入者添加）都已完成。

由于不同的流读者A和B在不同时间了解新事实，A和B可能对当前流ID存在分歧。
换句话说：我们应该将流读者视为彼此独立，以不同的速度处理事实流。

上述定义没有给出唯一的当前流ID，实际上可能有一系列当前流ID。Synapse在不同的情况下使用最小和最大ID。通常使用最大值，因为工作者通常希望尽快推进他们的ID。然而，在某些情况下，例如另一个工作者将等待流超过一个位置时，使用最小值。

**注意。** 对于“当前”的两种意义，如果写入者打开一个永远不会完成的事务，当前流ID将永远不会超过该写入者最后写入的流ID。

对于单写入者流，每个写入者的当前ID和线性当前ID是相同的。
两种意义上的当前ID都是单调的，但它们可能会“跳过”或跳过ID，因为事实完成的顺序不同。

_示例_。
考虑一个最初在ID 1的单写入者流。

| 动作     | 当前流ID | 备注                                           |
|------------|-------------------|-------------------------------------------------|
|            | 1                 |                                                 |
| 保留 2  | 1                 |                                                 |
| 保留 3  | 1                 |                                                 |
| 完成 3 | 1                 | 当前ID不变，等待2完成 |
| 完成 2 | 3                 | 当前ID从1跳到3                    |
| 保留 4  | 3                 |                                                 |
| 保留 5  | 3                 |                                                 |
| 保留 6  | 3                 |                                                 |
| 完成 5 | 3                 |                                                 |
| 完成 4 | 5                 | 当前ID从3跳到5，即使6待处理 |
| 完成 6 | 6                 |                                                 |

##### 多写入者流

有两种方式查看多写入者流。

1. 将其视为一组独立的单写入者流，每个写入者一个。
2. 将其视为单个流。

单个流（选项2）在概念上更简单，更容易表示（单个流ID）。
然而，这需要每个读者了解整个写入者集合，以确保读者不会错误地过早推进他们的当前流位置并错过来自未知写入者的事实。
相比之下，多个并行流（选项1）更复杂，需要更多的状态来表示（从写入者到流ID的映射）。
这样做的好处是，读者可以“窥视”一个写入者完成的事实，无论其他写入者的状态如何，从而减少延迟。

请注意，多写入者流可以以两种方式查看。
例如，事件流被同步处理程序视为多个单写入者流（选项1），以便尽快将事件发送给客户端。
但处理事件的后台进程将它们视为单个线性流。

另一个有用的例子是缓存失效流。
该流持有的事实是“您现在应该使这些缓存条目失效”的指令。
我们只将其视为多个单写入者流，因为缓存失效之间没有重要的顺序。
（失效是自包含的事实；失效是可交换的/是幂等的）。

##### 写入流

写入者需要跟踪：
 - 跟踪他们的当前位置（即其自己的每个写入者流ID）。
 - 当前等待完成的事实。

在启动时，
 - 可以通过查询数据库找到该写入者的当前位置（这表明事实需要在事务中原子地写入数据库）；并且
 - 没有事实等待完成。

要保留流ID，请在适当的postgres序列上调用[`nextval`](https://www.postgresql.org/docs/current/functions-sequence.html)。

要向流中写入事实：将适当的行插入到适当的后备表中。

要完成一个事实，首先将其从当前等待完成的事实映射中删除。
然后，如果没有更早的事实等待完成，写入者可以推进其在该流中的当前位置。
这样做后，它应该为每个事实在旧流ID和新流ID之间发出一个`RDATA`消息[3]。

##### 订阅流

读者需要跟踪每个写入者的当前位置。

在启动时，他们可以通过`REPLICATE`消息联系每个写入者，找到这一点，
请求所有写入者回复描述他们在流中的当前位置。
写入者通过`POSITION`消息回复。

要了解新事实，读者应监听`RDATA`消息并处理它们以响应新事实。
`RDATA`本身不是事实的自包含表示；
读者将不得不查询流表以获取完整详细信息。
读者还必须推进他们对该流中写入者当前位置的记录。

### 总结

简而言之：我们有一个追加的日志，其末尾有一个“缓冲区/草稿板”，我们必须等待序列线性和连续。

---

[^1]: 我们在这里使用“事实”这个词有两个原因。
首先，“事件”这个词已经被严重过载（PDU、EDU、账户数据……），我们不需要让它变得更糟。
其次，“事实”强调我们附加到流中的东西在事实发生后不能改变。

[^2]: 一个事实可能用0行表示，例如，如果我们打开一个事务以持久化一个事件，但在标记事实为完成之前失败并回滚了事务。
原则上，一个事实可能用2行或更多行表示；如果是这样，这些行中的每一行都应共享事实的流ID。

[^3]: 这种通信曾经直接与写入者[通过TCP](../../tcp_replication.md)进行；
如今，它是通过Redis的Pubsub完成的。