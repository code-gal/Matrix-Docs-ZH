### 授权链差异算法

授权链差异算法由 V2 状态解析使用，其中一个天真的实现可能是一个显著的 CPU 和数据库使用来源。

##### 定义

*状态集*是一组状态事件；例如，状态解析算法的输入是一组状态集。

一组事件的*授权链*是所有事件的授权事件及其授权事件，递归地（即，通过事件的授权事件链接诱导的图可达的所有事件）。

一组状态集的*授权链差异*是对应状态集的授权链的并集减去交集，即如果一个事件可以通过从至少一个状态集的授权事件图中到达但不是从*所有*状态集到达，则该事件在授权链差异中。

#### 广度优先遍历算法

一种在不计算每个状态集的完整授权链的情况下计算授权链差异的方法是并行地对每个状态集的授权链进行广度优先遍历（按深度排序）。通过跟踪哪些事件可以从每个状态集到达，我们可以在每个待处理事件都可从每个状态集到达时提前结束。

这对于授权链差异较小的状态集效果很好，但对于较大的差异可能非常低效。然而，如果我们没有房间的链覆盖索引（例如，因为我们正在索引它），仍然会使用此算法。

#### 链覆盖索引

Synapse 通过预计算房间中授权链的“链覆盖”索引来计算授权链差异，允许我们高效地进行可达性查询，如“事件 `A` 是否在事件 `B` 的授权链中？”。我们可以使用一个索引来跟踪所有 `(A, B)` 对，使得 `A` 在 `B` 的授权链中。然而，这将非常庞大，随着房间累积更多状态事件，扩展性很差。

相反，我们将图分解为*链*。链是 DAG 的子集，具有以下属性：对于链中的任何事件对 `E` 和 `F`，链包含路径 `E -> F` 或路径 `F -> E`。这强制链必须是线性的（没有分叉），例如 `E -> F -> G -> ... -> H`。链中的每个事件都有一个*序列号*，该序列号在该链中是本地的。链中最旧的事件 `E` 的序列号为 1。如果 `E` 在链中有子事件 `F`，则 `F` 的序列号为 2。如果 `E` 在链中有孙事件 `G`，则 `G` 的序列号为 3；依此类推。

Synapse 确保每个持久化的事件都属于一个链，并跟踪链之间的连接方式。这允许我们高效地回答可达性查询。这样做比按事件逐个跟踪可达性使用更少的存储，特别是当我们有更少且更长的链时。参见

> Jagadish, H. (1990). [压缩技术以实现传递闭包的物化](https://doi.org/10.1145/99935.99944)。
> *ACM Transactions on Database Systems (TODS)*, 15*(4)*, 558-598。

关于原始想法或

> Y. Chen, Y. Chen, [一种高效的图可达性查询回答算法](https://doi.org/10.1109/ICDE.2008.4497498)，
> 在：2008 IEEE 24th International Conference on Data Engineering，2008年4月，
> 页 893-902。 (PDF 可通过 [Google Scholar](https://scholar.google.com/scholar?q=Y.%20Chen,%20Y.%20Chen,%20An%20efficient%20algorithm%20for%20answering%20graph%20reachability%20queries,%20in:%202008%20IEEE%2024th%20International%20Conference%20on%20Data%20Engineering,%20April%202008,%20pp.%20893902.) 获得。)

关于更现代的观点。

在实际操作中，链覆盖为每个事件分配一个*链 ID* 和*序列号*（例如 `(5,3)`），并维护链之间事件的*链接*映射（例如 `(5,3) -> (2,4)`），使得 `A` 由 `B` 可达（即 `A` 在 `B` 的授权链中）当且仅当：

1. `A` 和 `B` 具有相同的链 ID 且 `A` 的序列号小于 `B` 的序列号；或
2. 存在一个链接 `L` 在 `B` 的链 ID 和 `A` 的链 ID 之间，使得 `L.start_seq_no` <= `B.seq_no` 且 `A.seq_no` <= `L.end_seq_no`。

实际上有两种可能的实现方式，一种是我们存储从每个链到每个其他可达链的链接（链接图的传递闭包），另一种是我们删除冗余链接（链接图的传递简化），例如，如果我们有链 `C3 -> C2 -> C1`，则不会存储链接 `C3 -> C1`。Synapse 使用前一种实现方式，这样它就不需要递归来测试链之间的可达性。这以额外的存储为代价来节省 CPU 周期和数据库查询。

##### 示例

一个示例授权图看起来如下，链基于类型/状态键形成，并以颜色表示，并标有 `(链 ID, 序列号)`。链接由箭头表示（灰色链接是上述第二种实现中将被删除的链接）。

![示例](Synapse%20Docs%20-%20中文/auth_chain_diff.dot.png)

请注意，我们没有包括所有事件与其授权事件之间的链接，因为大多数这些链接是冗余的。例如，所有事件都指向创建事件，但每个链只需要从其基准到创建事件的一个链接。

#### 使用索引

这个索引可以用来通过查看每个状态集可达的链 ID 和序列号来计算状态集的授权链差异：

1. 对于每个状态集，查找每个状态事件的链 ID/序列号。
2. 使用索引查找每个状态集可达的所有链和最大序列号。
3. 授权链差异则是所有在任何状态集可达的最大序列号和所有状态集可达的最小序列号之间的链中的事件（如果有的话）。

请注意，步骤 2 实际上是在计算每个状态集的授权链（以链 ID 和序列号的形式），而步骤 3 是在计算授权链的并集和交集之间的差异。

##### 工作示例

例如，根据上述图表，我们可以计算以下状态集之间的差异：

1. `S1`：Alice 的邀请 `(4,1)` 和 Bob 的第二次加入 `(2,2)`；以及
2. `S2`：Alice 的第二次加入 `(4,3)` 和 Bob 的第一次加入 `(2,1)`。

使用索引我们可以看到以下授权链可以从每个状态集到达：

1. `S1`：`(1,1)`、`(2,2)`、`(3,1)` 和 `(4,1)`
2. `S2`：`(1,1)`、`(2,1)`、`(3,2)` 和 `(4,3)`

因此，对于每个链的授权链差异范围为：
1. 链 1：无，因为所有状态集都可以到达创建事件。
2. 链 2：范围 `(1, 2]`（即仅 `2`），因为 `1` 可以被所有状态集到达，而最大可达的是 `2`（对应于 Bob 的第二次加入）。
3. 链 3：同样，范围 `(1, 2]`（对应于第二次权力等级）。
4. 链 4：范围 `(1, 3]`（对应于 Alice 的两次加入）。

所以最终结果是：Bob 的第二次加入 `(2,2)`、第二次权力等级 `(3,2)` 和 Alice 的两次加入 `(4,2)` 和 `(4,3)`。